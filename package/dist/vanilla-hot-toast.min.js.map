{"version":3,"sources":["../node_modules/.pnpm/preact@10.13.2/node_modules/preact/src/util.js","../node_modules/.pnpm/preact@10.13.2/node_modules/preact/src/options.js","../node_modules/.pnpm/preact@10.13.2/node_modules/preact/src/create-element.js","../node_modules/.pnpm/preact@10.13.2/node_modules/preact/src/component.js","../node_modules/.pnpm/preact@10.13.2/node_modules/preact/src/create-context.js","../node_modules/.pnpm/preact@10.13.2/node_modules/preact/src/constants.js","../node_modules/.pnpm/preact@10.13.2/node_modules/preact/src/diff/children.js","../node_modules/.pnpm/preact@10.13.2/node_modules/preact/src/diff/props.js","../node_modules/.pnpm/preact@10.13.2/node_modules/preact/src/diff/index.js","../node_modules/.pnpm/preact@10.13.2/node_modules/preact/src/render.js","../node_modules/.pnpm/preact@10.13.2/node_modules/preact/src/clone-element.js","../node_modules/.pnpm/preact@10.13.2/node_modules/preact/src/diff/catch-error.js","../node_modules/.pnpm/preact@10.13.2/node_modules/preact/hooks/src/index.js","../node_modules/preact/compat/src/util.js","../node_modules/preact/compat/src/PureComponent.js","../node_modules/preact/compat/src/memo.js","../node_modules/preact/compat/src/forwardRef.js","../node_modules/preact/compat/src/Children.js","../node_modules/preact/compat/src/suspense.js","../node_modules/preact/compat/src/suspense-list.js","../node_modules/preact/compat/src/portals.js","../node_modules/preact/compat/src/render.js","../node_modules/preact/compat/src/index.js","../node_modules/.pnpm/goober@2.1.13_csstype@3.1.2/node_modules/goober/dist/goober.modern.js","../node_modules/.pnpm/react-hot-toast@2.4.1_csstype@3.1.2_react-dom@18.2.0_react@18.2.0/node_modules/react-hot-toast/src/core/types.ts","../node_modules/.pnpm/react-hot-toast@2.4.1_csstype@3.1.2_react-dom@18.2.0_react@18.2.0/node_modules/react-hot-toast/src/core/utils.ts","../node_modules/.pnpm/react-hot-toast@2.4.1_csstype@3.1.2_react-dom@18.2.0_react@18.2.0/node_modules/react-hot-toast/src/core/store.ts","../node_modules/.pnpm/react-hot-toast@2.4.1_csstype@3.1.2_react-dom@18.2.0_react@18.2.0/node_modules/react-hot-toast/src/core/toast.ts","../node_modules/.pnpm/react-hot-toast@2.4.1_csstype@3.1.2_react-dom@18.2.0_react@18.2.0/node_modules/react-hot-toast/src/core/use-toaster.ts","../node_modules/.pnpm/react-hot-toast@2.4.1_csstype@3.1.2_react-dom@18.2.0_react@18.2.0/node_modules/react-hot-toast/src/components/toast-bar.tsx","../node_modules/.pnpm/react-hot-toast@2.4.1_csstype@3.1.2_react-dom@18.2.0_react@18.2.0/node_modules/react-hot-toast/src/components/toast-icon.tsx","../node_modules/.pnpm/react-hot-toast@2.4.1_csstype@3.1.2_react-dom@18.2.0_react@18.2.0/node_modules/react-hot-toast/src/components/error.tsx","../node_modules/.pnpm/react-hot-toast@2.4.1_csstype@3.1.2_react-dom@18.2.0_react@18.2.0/node_modules/react-hot-toast/src/components/loader.tsx","../node_modules/.pnpm/react-hot-toast@2.4.1_csstype@3.1.2_react-dom@18.2.0_react@18.2.0/node_modules/react-hot-toast/src/components/checkmark.tsx","../node_modules/.pnpm/react-hot-toast@2.4.1_csstype@3.1.2_react-dom@18.2.0_react@18.2.0/node_modules/react-hot-toast/src/components/toaster.tsx","../node_modules/.pnpm/react-hot-toast@2.4.1_csstype@3.1.2_react-dom@18.2.0_react@18.2.0/node_modules/react-hot-toast/src/index.ts","../src/index.tsx"],"sourcesContent":["import { EMPTY_ARR } from './constants';\n\n/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\t// @ts-ignore We change the type of `obj` to be `O & P`\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Remove a child node from its parent if attached. This is a workaround for\n * IE11 which doesn't support `Element.prototype.remove()`. Using this function\n * is smaller than including a dedicated polyfill.\n * @param {Node} node The node to remove\n */\nexport function removeNode(node) {\n\tlet parentNode = node.parentNode;\n\tif (parentNode) parentNode.removeChild(node);\n}\n\nexport const slice = EMPTY_ARR.slice;\n","import { _catchError } from './diff/catch-error';\n\n/**\n * The `option` object can potentially contain callback functions\n * that are called during various stages of our renderer. This is the\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\n * for a full list of available option hooks (most editors/IDEs allow you to\n * ctrl+click or cmd+click on mac the type definition below).\n * @type {import('./internal').Options}\n */\nconst options = {\n\t_catchError\n};\n\nexport default options;\n","import { slice } from './util';\nimport options from './options';\n\nlet vnodeId = 0;\n\n/**\n * Create an virtual node (used for JSX)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * constructor for this virtual node\n * @param {object | null | undefined} [props] The properties of the virtual node\n * @param {Array<import('.').ComponentChildren>} [children] The children of the virtual node\n * @returns {import('./internal').VNode}\n */\nexport function createElement(type, props, children) {\n\tlet normalizedProps = {},\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\t// If a Component VNode, check for and apply defaultProps\n\t// Note: type may be undefined in development, must never error here.\n\tif (typeof type == 'function' && type.defaultProps != null) {\n\t\tfor (i in type.defaultProps) {\n\t\t\tif (normalizedProps[i] === undefined) {\n\t\t\t\tnormalizedProps[i] = type.defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn createVNode(type, normalizedProps, key, ref, null);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object | string | number | null} props The properties of this virtual node.\n * If this virtual node represents a text node, this is the text of the node (string or number).\n * @param {string | number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {import('./internal').VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {import('./internal').VNode}\n */\nexport function createVNode(type, props, key, ref, original) {\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n\t// Do not inline into createElement and coerceToVNode!\n\tconst vnode = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\t_children: null,\n\t\t_parent: null,\n\t\t_depth: 0,\n\t\t_dom: null,\n\t\t// _nextDom must be initialized to undefined b/c it will eventually\n\t\t// be set to dom.nextSibling which can return `null` and it is important\n\t\t// to be able to distinguish between an uninitialized _nextDom and\n\t\t// a _nextDom that has been set to `null`\n\t\t_nextDom: undefined,\n\t\t_component: null,\n\t\t_hydrating: null,\n\t\tconstructor: undefined,\n\t\t_original: original == null ? ++vnodeId : original\n\t};\n\n\t// Only invoke the vnode hook if this was *not* a direct copy:\n\tif (original == null && options.vnode != null) options.vnode(vnode);\n\n\treturn vnode;\n}\n\nexport function createRef() {\n\treturn { current: null };\n}\n\nexport function Fragment(props) {\n\treturn props.children;\n}\n\n/**\n * Check if a the argument is a valid Preact VNode.\n * @param {*} vnode\n * @returns {vnode is import('./internal').VNode}\n */\nexport const isValidElement = vnode =>\n\tvnode != null && vnode.constructor === undefined;\n","import { assign } from './util';\nimport { diff, commitRoot } from './diff/index';\nimport options from './options';\nimport { Fragment } from './create-element';\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nexport function Component(props, context) {\n\tthis.props = props;\n\tthis.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @this {import('./internal').Component}\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nComponent.prototype.setState = function (update, callback) {\n\t// only clone state when copying to nextState the first time.\n\tlet s;\n\tif (this._nextState != null && this._nextState !== this.state) {\n\t\ts = this._nextState;\n\t} else {\n\t\ts = this._nextState = assign({}, this.state);\n\t}\n\n\tif (typeof update == 'function') {\n\t\t// Some libraries like `immer` mark the current state as readonly,\n\t\t// preventing us from mutating it, so we need to clone it. See #2716\n\t\tupdate = update(assign({}, s), this.props);\n\t}\n\n\tif (update) {\n\t\tassign(s, update);\n\t}\n\n\t// Skip update if updater function returned null\n\tif (update == null) return;\n\n\tif (this._vnode) {\n\t\tif (callback) {\n\t\t\tthis._stateCallbacks.push(callback);\n\t\t}\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @this {import('./internal').Component}\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nComponent.prototype.forceUpdate = function (callback) {\n\tif (this._vnode) {\n\t\t// Set render mode so that we can differentiate where the render request\n\t\t// is coming from. We need this because forceUpdate should never call\n\t\t// shouldComponentUpdate\n\t\tthis._force = true;\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {import('./index').ComponentChildren | void}\n */\nComponent.prototype.render = Fragment;\n\n/**\n * @param {import('./internal').VNode} vnode\n * @param {number | null} [childIndex]\n */\nexport function getDomSibling(vnode, childIndex) {\n\tif (childIndex == null) {\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\n\t\treturn vnode._parent\n\t\t\t? getDomSibling(vnode._parent, vnode._parent._children.indexOf(vnode) + 1)\n\t\t\t: null;\n\t}\n\n\tlet sibling;\n\tfor (; childIndex < vnode._children.length; childIndex++) {\n\t\tsibling = vnode._children[childIndex];\n\n\t\tif (sibling != null && sibling._dom != null) {\n\t\t\t// Since updateParentDomPointers keeps _dom pointer correct,\n\t\t\t// we can rely on _dom to tell us if this subtree contains a\n\t\t\t// rendered DOM node, and what the first rendered DOM node is\n\t\t\treturn sibling._dom;\n\t\t}\n\t}\n\n\t// If we get here, we have not found a DOM node in this vnode's children.\n\t// We must resume from this vnode's sibling (in it's parent _children array)\n\t// Only climb up and search the parent if we aren't searching through a DOM\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\n\t// the search)\n\treturn typeof vnode.type == 'function' ? getDomSibling(vnode) : null;\n}\n\n/**\n * Trigger in-place re-rendering of a component.\n * @param {import('./internal').Component} component The component to rerender\n */\nfunction renderComponent(component) {\n\tlet vnode = component._vnode,\n\t\toldDom = vnode._dom,\n\t\tparentDom = component._parentDom;\n\n\tif (parentDom) {\n\t\tlet commitQueue = [];\n\t\tconst oldVNode = assign({}, vnode);\n\t\toldVNode._original = vnode._original + 1;\n\n\t\tdiff(\n\t\t\tparentDom,\n\t\t\tvnode,\n\t\t\toldVNode,\n\t\t\tcomponent._globalContext,\n\t\t\tparentDom.ownerSVGElement !== undefined,\n\t\t\tvnode._hydrating != null ? [oldDom] : null,\n\t\t\tcommitQueue,\n\t\t\toldDom == null ? getDomSibling(vnode) : oldDom,\n\t\t\tvnode._hydrating\n\t\t);\n\t\tcommitRoot(commitQueue, vnode);\n\n\t\tif (vnode._dom != oldDom) {\n\t\t\tupdateParentDomPointers(vnode);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('./internal').VNode} vnode\n */\nfunction updateParentDomPointers(vnode) {\n\tif ((vnode = vnode._parent) != null && vnode._component != null) {\n\t\tvnode._dom = vnode._component.base = null;\n\t\tfor (let i = 0; i < vnode._children.length; i++) {\n\t\t\tlet child = vnode._children[i];\n\t\t\tif (child != null && child._dom != null) {\n\t\t\t\tvnode._dom = vnode._component.base = child._dom;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn updateParentDomPointers(vnode);\n\t}\n}\n\n/**\n * The render queue\n * @type {Array<import('./internal').Component>}\n */\nlet rerenderQueue = [];\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nlet prevDebounce;\n\nconst defer =\n\ttypeof Promise == 'function'\n\t\t? Promise.prototype.then.bind(Promise.resolve())\n\t\t: setTimeout;\n\n/**\n * Enqueue a rerender of a component\n * @param {import('./internal').Component} c The component to rerender\n */\nexport function enqueueRender(c) {\n\tif (\n\t\t(!c._dirty &&\n\t\t\t(c._dirty = true) &&\n\t\t\trerenderQueue.push(c) &&\n\t\t\t!process._rerenderCount++) ||\n\t\tprevDebounce !== options.debounceRendering\n\t) {\n\t\tprevDebounce = options.debounceRendering;\n\t\t(prevDebounce || defer)(process);\n\t}\n}\n\n/**\n * @param {import('./internal').Component} a\n * @param {import('./internal').Component} b\n */\nconst depthSort = (a, b) => a._vnode._depth - b._vnode._depth;\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n\tlet c;\n\trerenderQueue.sort(depthSort);\n\t// Don't update `renderCount` yet. Keep its value non-zero to prevent unnecessary\n\t// process() calls from getting scheduled while `queue` is still being consumed.\n\twhile ((c = rerenderQueue.shift())) {\n\t\tif (c._dirty) {\n\t\t\tlet renderQueueLength = rerenderQueue.length;\n\t\t\trenderComponent(c);\n\t\t\tif (rerenderQueue.length > renderQueueLength) {\n\t\t\t\t// When i.e. rerendering a provider additional new items can be injected, we want to\n\t\t\t\t// keep the order from top to bottom with those new items so we can handle them in a\n\t\t\t\t// single pass\n\t\t\t\trerenderQueue.sort(depthSort);\n\t\t\t}\n\t\t}\n\t}\n\tprocess._rerenderCount = 0;\n}\n\nprocess._rerenderCount = 0;\n","import { enqueueRender } from './component';\n\nexport let i = 0;\n\nexport function createContext(defaultValue, contextId) {\n\tcontextId = '__cC' + i++;\n\n\tconst context = {\n\t\t_id: contextId,\n\t\t_defaultValue: defaultValue,\n\t\t/** @type {import('./internal').FunctionComponent} */\n\t\tConsumer(props, contextValue) {\n\t\t\t// return props.children(\n\t\t\t// \tcontext[contextId] ? context[contextId].props.value : defaultValue\n\t\t\t// );\n\t\t\treturn props.children(contextValue);\n\t\t},\n\t\t/** @type {import('./internal').FunctionComponent} */\n\t\tProvider(props) {\n\t\t\tif (!this.getChildContext) {\n\t\t\t\t/** @type {import('./internal').Component[]} */\n\t\t\t\tlet subs = [];\n\t\t\t\tlet ctx = {};\n\t\t\t\tctx[contextId] = this;\n\n\t\t\t\tthis.getChildContext = () => ctx;\n\n\t\t\t\tthis.shouldComponentUpdate = function (_props) {\n\t\t\t\t\tif (this.props.value !== _props.value) {\n\t\t\t\t\t\t// I think the forced value propagation here was only needed when `options.debounceRendering` was being bypassed:\n\t\t\t\t\t\t// https://github.com/preactjs/preact/commit/4d339fb803bea09e9f198abf38ca1bf8ea4b7771#diff-54682ce380935a717e41b8bfc54737f6R358\n\t\t\t\t\t\t// In those cases though, even with the value corrected, we're double-rendering all nodes.\n\t\t\t\t\t\t// It might be better to just tell folks not to use force-sync mode.\n\t\t\t\t\t\t// Currently, using `useContext()` in a class component will overwrite its `this.context` value.\n\t\t\t\t\t\t// subs.some(c => {\n\t\t\t\t\t\t// \tc.context = _props.value;\n\t\t\t\t\t\t// \tenqueueRender(c);\n\t\t\t\t\t\t// });\n\n\t\t\t\t\t\t// subs.some(c => {\n\t\t\t\t\t\t// \tc.context[contextId] = _props.value;\n\t\t\t\t\t\t// \tenqueueRender(c);\n\t\t\t\t\t\t// });\n\t\t\t\t\t\tsubs.some(c => {\n\t\t\t\t\t\t\tc._force = true;\n\t\t\t\t\t\t\tenqueueRender(c);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tthis.sub = c => {\n\t\t\t\t\tsubs.push(c);\n\t\t\t\t\tlet old = c.componentWillUnmount;\n\t\t\t\t\tc.componentWillUnmount = () => {\n\t\t\t\t\t\tsubs.splice(subs.indexOf(c), 1);\n\t\t\t\t\t\tif (old) old.call(c);\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn props.children;\n\t\t}\n\t};\n\n\t// Devtools needs access to the context object when it\n\t// encounters a Provider. This is necessary to support\n\t// setting `displayName` on the context object instead\n\t// of on the component itself. See:\n\t// https://reactjs.org/docs/context.html#contextdisplayname\n\n\treturn (context.Provider._contextRef = context.Consumer.contextType =\n\t\tcontext);\n}\n","export const EMPTY_OBJ = {};\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL =\n\t/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n","import { diff, unmount, applyRef } from './index';\nimport { createVNode, Fragment } from '../create-element';\nimport { EMPTY_OBJ, EMPTY_ARR } from '../constants';\nimport { getDomSibling } from '../component';\n\n/**\n * Diff the children of a virtual node\n * @param {import('../internal').PreactElement} parentDom The DOM element whose\n * children are being diffed\n * @param {import('../internal').ComponentChildren[]} renderResult\n * @param {import('../internal').VNode} newParentVNode The new virtual\n * node whose children should be diff'ed against oldParentVNode\n * @param {import('../internal').VNode} oldParentVNode The old virtual\n * node whose children should be diff'ed against newParentVNode\n * @param {object} globalContext The current context object - modified by getChildContext\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\n * @param {Array<import('../internal').PreactElement>} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {import('../internal').PreactElement} oldDom The current attached DOM\n * element any new dom elements should be placed around. Likely `null` on first\n * render (except when hydrating). Can be a sibling DOM element when diffing\n * Fragments that have siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n */\nexport function diffChildren(\n\tparentDom,\n\trenderResult,\n\tnewParentVNode,\n\toldParentVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating\n) {\n\tlet i, j, oldVNode, childVNode, newDom, firstChildDom, refs;\n\n\t// This is a compression of oldParentVNode!=null && oldParentVNode != EMPTY_OBJ && oldParentVNode._children || EMPTY_ARR\n\t// as EMPTY_OBJ._children should be `undefined`.\n\tlet oldChildren = (oldParentVNode && oldParentVNode._children) || EMPTY_ARR;\n\n\tlet oldChildrenLength = oldChildren.length;\n\n\tnewParentVNode._children = [];\n\tfor (i = 0; i < renderResult.length; i++) {\n\t\tchildVNode = renderResult[i];\n\n\t\tif (\n\t\t\tchildVNode == null ||\n\t\t\ttypeof childVNode == 'boolean' ||\n\t\t\ttypeof childVNode == 'function'\n\t\t) {\n\t\t\tchildVNode = newParentVNode._children[i] = null;\n\t\t}\n\t\t// If this newVNode is being reused (e.g. <div>{reuse}{reuse}</div>) in the same diff,\n\t\t// or we are rendering a component (e.g. setState) copy the oldVNodes so it can have\n\t\t// it's own DOM & etc. pointers\n\t\telse if (\n\t\t\ttypeof childVNode == 'string' ||\n\t\t\ttypeof childVNode == 'number' ||\n\t\t\t// eslint-disable-next-line valid-typeof\n\t\t\ttypeof childVNode == 'bigint'\n\t\t) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tnull,\n\t\t\t\tchildVNode,\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tchildVNode\n\t\t\t);\n\t\t} else if (Array.isArray(childVNode)) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tFragment,\n\t\t\t\t{ children: childVNode },\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tnull\n\t\t\t);\n\t\t} else if (childVNode._depth > 0) {\n\t\t\t// VNode is already in use, clone it. This can happen in the following\n\t\t\t// scenario:\n\t\t\t//   const reuse = <div />\n\t\t\t//   <div>{reuse}<span />{reuse}</div>\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tchildVNode.type,\n\t\t\t\tchildVNode.props,\n\t\t\t\tchildVNode.key,\n\t\t\t\tchildVNode.ref ? childVNode.ref : null,\n\t\t\t\tchildVNode._original\n\t\t\t);\n\t\t} else {\n\t\t\tchildVNode = newParentVNode._children[i] = childVNode;\n\t\t}\n\n\t\t// Terser removes the `continue` here and wraps the loop body\n\t\t// in a `if (childVNode) { ... } condition\n\t\tif (childVNode == null) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tchildVNode._parent = newParentVNode;\n\t\tchildVNode._depth = newParentVNode._depth + 1;\n\n\t\t// Check if we find a corresponding element in oldChildren.\n\t\t// If found, delete the array item by setting to `undefined`.\n\t\t// We use `undefined`, as `null` is reserved for empty placeholders\n\t\t// (holes).\n\t\toldVNode = oldChildren[i];\n\n\t\tif (\n\t\t\toldVNode === null ||\n\t\t\t(oldVNode &&\n\t\t\t\tchildVNode.key == oldVNode.key &&\n\t\t\t\tchildVNode.type === oldVNode.type)\n\t\t) {\n\t\t\toldChildren[i] = undefined;\n\t\t} else {\n\t\t\t// Either oldVNode === undefined or oldChildrenLength > 0,\n\t\t\t// so after this loop oldVNode == null or oldVNode is a valid value.\n\t\t\tfor (j = 0; j < oldChildrenLength; j++) {\n\t\t\t\toldVNode = oldChildren[j];\n\t\t\t\t// If childVNode is unkeyed, we only match similarly unkeyed nodes, otherwise we match by key.\n\t\t\t\t// We always match by type (in either case).\n\t\t\t\tif (\n\t\t\t\t\toldVNode &&\n\t\t\t\t\tchildVNode.key == oldVNode.key &&\n\t\t\t\t\tchildVNode.type === oldVNode.type\n\t\t\t\t) {\n\t\t\t\t\toldChildren[j] = undefined;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\toldVNode = null;\n\t\t\t}\n\t\t}\n\n\t\toldVNode = oldVNode || EMPTY_OBJ;\n\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\tdiff(\n\t\t\tparentDom,\n\t\t\tchildVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tisSvg,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\toldDom,\n\t\t\tisHydrating\n\t\t);\n\n\t\tnewDom = childVNode._dom;\n\n\t\tif ((j = childVNode.ref) && oldVNode.ref != j) {\n\t\t\tif (!refs) refs = [];\n\t\t\tif (oldVNode.ref) refs.push(oldVNode.ref, null, childVNode);\n\t\t\trefs.push(j, childVNode._component || newDom, childVNode);\n\t\t}\n\n\t\tif (newDom != null) {\n\t\t\tif (firstChildDom == null) {\n\t\t\t\tfirstChildDom = newDom;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\ttypeof childVNode.type == 'function' &&\n\t\t\t\tchildVNode._children === oldVNode._children\n\t\t\t) {\n\t\t\t\tchildVNode._nextDom = oldDom = reorderChildren(\n\t\t\t\t\tchildVNode,\n\t\t\t\t\toldDom,\n\t\t\t\t\tparentDom\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\toldDom = placeChild(\n\t\t\t\t\tparentDom,\n\t\t\t\t\tchildVNode,\n\t\t\t\t\toldVNode,\n\t\t\t\t\toldChildren,\n\t\t\t\t\tnewDom,\n\t\t\t\t\toldDom\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (typeof newParentVNode.type == 'function') {\n\t\t\t\t// Because the newParentVNode is Fragment-like, we need to set it's\n\t\t\t\t// _nextDom property to the nextSibling of its last child DOM node.\n\t\t\t\t//\n\t\t\t\t// `oldDom` contains the correct value here because if the last child\n\t\t\t\t// is a Fragment-like, then oldDom has already been set to that child's _nextDom.\n\t\t\t\t// If the last child is a DOM VNode, then oldDom will be set to that DOM\n\t\t\t\t// node's nextSibling.\n\t\t\t\tnewParentVNode._nextDom = oldDom;\n\t\t\t}\n\t\t} else if (\n\t\t\toldDom &&\n\t\t\toldVNode._dom == oldDom &&\n\t\t\toldDom.parentNode != parentDom\n\t\t) {\n\t\t\t// The above condition is to handle null placeholders. See test in placeholder.test.js:\n\t\t\t// `efficiently replace null placeholders in parent rerenders`\n\t\t\toldDom = getDomSibling(oldVNode);\n\t\t}\n\t}\n\n\tnewParentVNode._dom = firstChildDom;\n\n\t// Remove remaining oldChildren if there are any.\n\tfor (i = oldChildrenLength; i--; ) {\n\t\tif (oldChildren[i] != null) {\n\t\t\tif (\n\t\t\t\ttypeof newParentVNode.type == 'function' &&\n\t\t\t\toldChildren[i]._dom != null &&\n\t\t\t\toldChildren[i]._dom == newParentVNode._nextDom\n\t\t\t) {\n\t\t\t\t// If the newParentVNode.__nextDom points to a dom node that is about to\n\t\t\t\t// be unmounted, then get the next sibling of that vnode and set\n\t\t\t\t// _nextDom to it\n\t\t\t\tnewParentVNode._nextDom = getLastDom(oldParentVNode).nextSibling;\n\t\t\t}\n\n\t\t\tunmount(oldChildren[i], oldChildren[i]);\n\t\t}\n\t}\n\n\t// Set refs only after unmount\n\tif (refs) {\n\t\tfor (i = 0; i < refs.length; i++) {\n\t\t\tapplyRef(refs[i], refs[++i], refs[++i]);\n\t\t}\n\t}\n}\n\nfunction reorderChildren(childVNode, oldDom, parentDom) {\n\t// Note: VNodes in nested suspended trees may be missing _children.\n\tlet c = childVNode._children;\n\tlet tmp = 0;\n\tfor (; c && tmp < c.length; tmp++) {\n\t\tlet vnode = c[tmp];\n\t\tif (vnode) {\n\t\t\t// We typically enter this code path on sCU bailout, where we copy\n\t\t\t// oldVNode._children to newVNode._children. If that is the case, we need\n\t\t\t// to update the old children's _parent pointer to point to the newVNode\n\t\t\t// (childVNode here).\n\t\t\tvnode._parent = childVNode;\n\n\t\t\tif (typeof vnode.type == 'function') {\n\t\t\t\toldDom = reorderChildren(vnode, oldDom, parentDom);\n\t\t\t} else {\n\t\t\t\toldDom = placeChild(parentDom, vnode, vnode, c, vnode._dom, oldDom);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn oldDom;\n}\n\n/**\n * Flatten and loop through the children of a virtual node\n * @param {import('../index').ComponentChildren} children The unflattened\n * children of a virtual node\n * @returns {import('../internal').VNode[]}\n */\nexport function toChildArray(children, out) {\n\tout = out || [];\n\tif (children == null || typeof children == 'boolean') {\n\t} else if (Array.isArray(children)) {\n\t\tchildren.some(child => {\n\t\t\ttoChildArray(child, out);\n\t\t});\n\t} else {\n\t\tout.push(children);\n\t}\n\treturn out;\n}\n\nfunction placeChild(\n\tparentDom,\n\tchildVNode,\n\toldVNode,\n\toldChildren,\n\tnewDom,\n\toldDom\n) {\n\tlet nextDom;\n\tif (childVNode._nextDom !== undefined) {\n\t\t// Only Fragments or components that return Fragment like VNodes will\n\t\t// have a non-undefined _nextDom. Continue the diff from the sibling\n\t\t// of last DOM child of this child VNode\n\t\tnextDom = childVNode._nextDom;\n\n\t\t// Eagerly cleanup _nextDom. We don't need to persist the value because\n\t\t// it is only used by `diffChildren` to determine where to resume the diff after\n\t\t// diffing Components and Fragments. Once we store it the nextDOM local var, we\n\t\t// can clean up the property\n\t\tchildVNode._nextDom = undefined;\n\t} else if (\n\t\toldVNode == null ||\n\t\tnewDom != oldDom ||\n\t\tnewDom.parentNode == null\n\t) {\n\t\touter: if (oldDom == null || oldDom.parentNode !== parentDom) {\n\t\t\tparentDom.appendChild(newDom);\n\t\t\tnextDom = null;\n\t\t} else {\n\t\t\t// `j<oldChildrenLength; j+=2` is an alternative to `j++<oldChildrenLength/2`\n\t\t\tfor (\n\t\t\t\tlet sibDom = oldDom, j = 0;\n\t\t\t\t(sibDom = sibDom.nextSibling) && j < oldChildren.length;\n\t\t\t\tj += 1\n\t\t\t) {\n\t\t\t\tif (sibDom == newDom) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t}\n\t\t\tparentDom.insertBefore(newDom, oldDom);\n\t\t\tnextDom = oldDom;\n\t\t}\n\t}\n\n\t// If we have pre-calculated the nextDOM node, use it. Else calculate it now\n\t// Strictly check for `undefined` here cuz `null` is a valid value of `nextDom`.\n\t// See more detail in create-element.js:createVNode\n\tif (nextDom !== undefined) {\n\t\toldDom = nextDom;\n\t} else {\n\t\toldDom = newDom.nextSibling;\n\t}\n\n\treturn oldDom;\n}\n\n/**\n * @param {import('../internal').VNode} vnode\n */\nfunction getLastDom(vnode) {\n\tif (vnode.type == null || typeof vnode.type === 'string') {\n\t\treturn vnode._dom;\n\t}\n\n\tif (vnode._children) {\n\t\tfor (let i = vnode._children.length - 1; i >= 0; i--) {\n\t\t\tlet child = vnode._children[i];\n\t\t\tif (child) {\n\t\t\t\tlet lastDom = getLastDom(child);\n\t\t\t\tif (lastDom) {\n\t\t\t\t\treturn lastDom;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n}\n","import { IS_NON_DIMENSIONAL } from '../constants';\nimport options from '../options';\n\n/**\n * Diff the old and new properties of a VNode and apply changes to the DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to apply\n * changes to\n * @param {object} newProps The new props\n * @param {object} oldProps The old props\n * @param {boolean} isSvg Whether or not this node is an SVG node\n * @param {boolean} hydrate Whether or not we are in hydration mode\n */\nexport function diffProps(dom, newProps, oldProps, isSvg, hydrate) {\n\tlet i;\n\n\tfor (i in oldProps) {\n\t\tif (i !== 'children' && i !== 'key' && !(i in newProps)) {\n\t\t\tsetProperty(dom, i, null, oldProps[i], isSvg);\n\t\t}\n\t}\n\n\tfor (i in newProps) {\n\t\tif (\n\t\t\t(!hydrate || typeof newProps[i] == 'function') &&\n\t\t\ti !== 'children' &&\n\t\t\ti !== 'key' &&\n\t\t\ti !== 'value' &&\n\t\t\ti !== 'checked' &&\n\t\t\toldProps[i] !== newProps[i]\n\t\t) {\n\t\t\tsetProperty(dom, i, newProps[i], oldProps[i], isSvg);\n\t\t}\n\t}\n}\n\nfunction setStyle(style, key, value) {\n\tif (key[0] === '-') {\n\t\tstyle.setProperty(key, value == null ? '' : value);\n\t} else if (value == null) {\n\t\tstyle[key] = '';\n\t} else if (typeof value != 'number' || IS_NON_DIMENSIONAL.test(key)) {\n\t\tstyle[key] = value;\n\t} else {\n\t\tstyle[key] = value + 'px';\n\t}\n}\n\n/**\n * Set a property value on a DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node or not\n */\nexport function setProperty(dom, name, value, oldValue, isSvg) {\n\tlet useCapture;\n\n\to: if (name === 'style') {\n\t\tif (typeof value == 'string') {\n\t\t\tdom.style.cssText = value;\n\t\t} else {\n\t\t\tif (typeof oldValue == 'string') {\n\t\t\t\tdom.style.cssText = oldValue = '';\n\t\t\t}\n\n\t\t\tif (oldValue) {\n\t\t\t\tfor (name in oldValue) {\n\t\t\t\t\tif (!(value && name in value)) {\n\t\t\t\t\t\tsetStyle(dom.style, name, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (value) {\n\t\t\t\tfor (name in value) {\n\t\t\t\t\tif (!oldValue || value[name] !== oldValue[name]) {\n\t\t\t\t\t\tsetStyle(dom.style, name, value[name]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n\telse if (name[0] === 'o' && name[1] === 'n') {\n\t\tuseCapture = name !== (name = name.replace(/Capture$/, ''));\n\n\t\t// Infer correct casing for DOM built-in events:\n\t\tif (name.toLowerCase() in dom) name = name.toLowerCase().slice(2);\n\t\telse name = name.slice(2);\n\n\t\tif (!dom._listeners) dom._listeners = {};\n\t\tdom._listeners[name + useCapture] = value;\n\n\t\tif (value) {\n\t\t\tif (!oldValue) {\n\t\t\t\tconst handler = useCapture ? eventProxyCapture : eventProxy;\n\t\t\t\tdom.addEventListener(name, handler, useCapture);\n\t\t\t}\n\t\t} else {\n\t\t\tconst handler = useCapture ? eventProxyCapture : eventProxy;\n\t\t\tdom.removeEventListener(name, handler, useCapture);\n\t\t}\n\t} else if (name !== 'dangerouslySetInnerHTML') {\n\t\tif (isSvg) {\n\t\t\t// Normalize incorrect prop usage for SVG:\n\t\t\t// - xlink:href / xlinkHref --> href (xlink:href was removed from SVG and isn't needed)\n\t\t\t// - className --> class\n\t\t\tname = name.replace(/xlink(H|:h)/, 'h').replace(/sName$/, 's');\n\t\t} else if (\n\t\t\tname !== 'width' &&\n\t\t\tname !== 'height' &&\n\t\t\tname !== 'href' &&\n\t\t\tname !== 'list' &&\n\t\t\tname !== 'form' &&\n\t\t\t// Default value in browsers is `-1` and an empty string is\n\t\t\t// cast to `0` instead\n\t\t\tname !== 'tabIndex' &&\n\t\t\tname !== 'download' &&\n\t\t\tname in dom\n\t\t) {\n\t\t\ttry {\n\t\t\t\tdom[name] = value == null ? '' : value;\n\t\t\t\t// labelled break is 1b smaller here than a return statement (sorry)\n\t\t\t\tbreak o;\n\t\t\t} catch (e) {}\n\t\t}\n\n\t\t// aria- and data- attributes have no boolean representation.\n\t\t// A `false` value is different from the attribute not being\n\t\t// present, so we can't remove it. For non-boolean aria\n\t\t// attributes we could treat false as a removal, but the\n\t\t// amount of exceptions would cost too many bytes. On top of\n\t\t// that other frameworks generally stringify `false`.\n\n\t\tif (typeof value === 'function') {\n\t\t\t// never serialize functions as attribute values\n\t\t} else if (value != null && (value !== false || name[4] === '-')) {\n\t\t\tdom.setAttribute(name, value);\n\t\t} else {\n\t\t\tdom.removeAttribute(name);\n\t\t}\n\t}\n}\n\n/**\n * Proxy an event to hooked event handlers\n * @param {Event} e The event object from the browser\n * @private\n */\nfunction eventProxy(e) {\n\treturn this._listeners[e.type + false](options.event ? options.event(e) : e);\n}\n\nfunction eventProxyCapture(e) {\n\treturn this._listeners[e.type + true](options.event ? options.event(e) : e);\n}\n","import { EMPTY_OBJ } from '../constants';\nimport { Component, getDomSibling } from '../component';\nimport { Fragment } from '../create-element';\nimport { diffChildren } from './children';\nimport { diffProps, setProperty } from './props';\nimport { assign, removeNode, slice } from '../util';\nimport options from '../options';\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {import('../internal').PreactElement} parentDom The parent of the DOM element\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object. Modified by getChildContext\n * @param {boolean} isSvg Whether or not this element is an SVG node\n * @param {Array<import('../internal').PreactElement>} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {import('../internal').PreactElement} oldDom The current attached DOM\n * element any new dom elements should be placed around. Likely `null` on first\n * render (except when hydrating). Can be a sibling DOM element when diffing\n * Fragments that have siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} [isHydrating] Whether or not we are in hydration\n */\nexport function diff(\n\tparentDom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating\n) {\n\tlet tmp,\n\t\tnewType = newVNode.type;\n\n\t// When passing through createElement it assigns the object\n\t// constructor as undefined. This to prevent JSON-injection.\n\tif (newVNode.constructor !== undefined) return null;\n\n\t// If the previous diff bailed out, resume creating/hydrating.\n\tif (oldVNode._hydrating != null) {\n\t\tisHydrating = oldVNode._hydrating;\n\t\toldDom = newVNode._dom = oldVNode._dom;\n\t\t// if we resume, we want the tree to be \"unlocked\"\n\t\tnewVNode._hydrating = null;\n\t\texcessDomChildren = [oldDom];\n\t}\n\n\tif ((tmp = options._diff)) tmp(newVNode);\n\n\ttry {\n\t\touter: if (typeof newType == 'function') {\n\t\t\tlet c, isNew, oldProps, oldState, snapshot, clearProcessingException;\n\t\t\tlet newProps = newVNode.props;\n\n\t\t\t// Necessary for createContext api. Setting this property will pass\n\t\t\t// the context value as `this.context` just for this component.\n\t\t\ttmp = newType.contextType;\n\t\t\tlet provider = tmp && globalContext[tmp._id];\n\t\t\tlet componentContext = tmp\n\t\t\t\t? provider\n\t\t\t\t\t? provider.props.value\n\t\t\t\t\t: tmp._defaultValue\n\t\t\t\t: globalContext;\n\n\t\t\t// Get component and set it to `c`\n\t\t\tif (oldVNode._component) {\n\t\t\t\tc = newVNode._component = oldVNode._component;\n\t\t\t\tclearProcessingException = c._processingException = c._pendingError;\n\t\t\t} else {\n\t\t\t\t// Instantiate the new component\n\t\t\t\tif ('prototype' in newType && newType.prototype.render) {\n\t\t\t\t\t// @ts-ignore The check above verifies that newType is suppose to be constructed\n\t\t\t\t\tnewVNode._component = c = new newType(newProps, componentContext); // eslint-disable-line new-cap\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-ignore Trust me, Component implements the interface we want\n\t\t\t\t\tnewVNode._component = c = new Component(newProps, componentContext);\n\t\t\t\t\tc.constructor = newType;\n\t\t\t\t\tc.render = doRender;\n\t\t\t\t}\n\t\t\t\tif (provider) provider.sub(c);\n\n\t\t\t\tc.props = newProps;\n\t\t\t\tif (!c.state) c.state = {};\n\t\t\t\tc.context = componentContext;\n\t\t\t\tc._globalContext = globalContext;\n\t\t\t\tisNew = c._dirty = true;\n\t\t\t\tc._renderCallbacks = [];\n\t\t\t\tc._stateCallbacks = [];\n\t\t\t}\n\n\t\t\t// Invoke getDerivedStateFromProps\n\t\t\tif (c._nextState == null) {\n\t\t\t\tc._nextState = c.state;\n\t\t\t}\n\n\t\t\tif (newType.getDerivedStateFromProps != null) {\n\t\t\t\tif (c._nextState == c.state) {\n\t\t\t\t\tc._nextState = assign({}, c._nextState);\n\t\t\t\t}\n\n\t\t\t\tassign(\n\t\t\t\t\tc._nextState,\n\t\t\t\t\tnewType.getDerivedStateFromProps(newProps, c._nextState)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\toldProps = c.props;\n\t\t\toldState = c.state;\n\t\t\tc._vnode = newVNode;\n\n\t\t\t// Invoke pre-render lifecycle methods\n\t\t\tif (isNew) {\n\t\t\t\tif (\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tc.componentWillMount != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillMount();\n\t\t\t\t}\n\n\t\t\t\tif (c.componentDidMount != null) {\n\t\t\t\t\tc._renderCallbacks.push(c.componentDidMount);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tnewProps !== oldProps &&\n\t\t\t\t\tc.componentWillReceiveProps != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillReceiveProps(newProps, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t(!c._force &&\n\t\t\t\t\t\tc.shouldComponentUpdate != null &&\n\t\t\t\t\t\tc.shouldComponentUpdate(\n\t\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\t\tc._nextState,\n\t\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t\t) === false) ||\n\t\t\t\t\tnewVNode._original === oldVNode._original\n\t\t\t\t) {\n\t\t\t\t\t// More info about this here: https://gist.github.com/JoviDeCroock/bec5f2ce93544d2e6070ef8e0036e4e8\n\t\t\t\t\tif (newVNode._original !== oldVNode._original) {\n\t\t\t\t\t\t// When we are dealing with a bail because of sCU we have to update\n\t\t\t\t\t\t// the props, state and dirty-state.\n\t\t\t\t\t\t// when we are dealing with strict-equality we don't as the child could still\n\t\t\t\t\t\t// be dirtied see #3883\n\t\t\t\t\t\tc.props = newProps;\n\t\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t\t\tc._dirty = false;\n\t\t\t\t\t}\n\n\t\t\t\t\t// In cases of bailing due to strict-equality we have to reset force as well\n\t\t\t\t\tc._force = false;\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t\tnewVNode._children.forEach(vnode => {\n\t\t\t\t\t\tif (vnode) vnode._parent = newVNode;\n\t\t\t\t\t});\n\n\t\t\t\t\tfor (let i = 0; i < c._stateCallbacks.length; i++) {\n\t\t\t\t\t\tc._renderCallbacks.push(c._stateCallbacks[i]);\n\t\t\t\t\t}\n\t\t\t\t\tc._stateCallbacks = [];\n\n\t\t\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\t\t\tcommitQueue.push(c);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\n\t\t\t\tif (c.componentWillUpdate != null) {\n\t\t\t\t\tc.componentWillUpdate(newProps, c._nextState, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (c.componentDidUpdate != null) {\n\t\t\t\t\tc._renderCallbacks.push(() => {\n\t\t\t\t\t\tc.componentDidUpdate(oldProps, oldState, snapshot);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.context = componentContext;\n\t\t\tc.props = newProps;\n\t\t\tc._parentDom = parentDom;\n\n\t\t\tlet renderHook = options._render,\n\t\t\t\tcount = 0;\n\t\t\tif ('prototype' in newType && newType.prototype.render) {\n\t\t\t\tc.state = c._nextState;\n\t\t\t\tc._dirty = false;\n\n\t\t\t\tif (renderHook) renderHook(newVNode);\n\n\t\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t\tfor (let i = 0; i < c._stateCallbacks.length; i++) {\n\t\t\t\t\tc._renderCallbacks.push(c._stateCallbacks[i]);\n\t\t\t\t}\n\t\t\t\tc._stateCallbacks = [];\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tc._dirty = false;\n\t\t\t\t\tif (renderHook) renderHook(newVNode);\n\n\t\t\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t\t\t// Handle setState called in render, see #2553\n\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t} while (c._dirty && ++count < 25);\n\t\t\t}\n\n\t\t\t// Handle setState called in render, see #2553\n\t\t\tc.state = c._nextState;\n\n\t\t\tif (c.getChildContext != null) {\n\t\t\t\tglobalContext = assign(assign({}, globalContext), c.getChildContext());\n\t\t\t}\n\n\t\t\tif (!isNew && c.getSnapshotBeforeUpdate != null) {\n\t\t\t\tsnapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\n\t\t\t}\n\n\t\t\tlet isTopLevelFragment =\n\t\t\t\ttmp != null && tmp.type === Fragment && tmp.key == null;\n\t\t\tlet renderResult = isTopLevelFragment ? tmp.props.children : tmp;\n\n\t\t\tdiffChildren(\n\t\t\t\tparentDom,\n\t\t\t\tArray.isArray(renderResult) ? renderResult : [renderResult],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\toldDom,\n\t\t\t\tisHydrating\n\t\t\t);\n\n\t\t\tc.base = newVNode._dom;\n\n\t\t\t// We successfully rendered this VNode, unset any stored hydration/bailout state:\n\t\t\tnewVNode._hydrating = null;\n\n\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\tcommitQueue.push(c);\n\t\t\t}\n\n\t\t\tif (clearProcessingException) {\n\t\t\t\tc._pendingError = c._processingException = null;\n\t\t\t}\n\n\t\t\tc._force = false;\n\t\t} else if (\n\t\t\texcessDomChildren == null &&\n\t\t\tnewVNode._original === oldVNode._original\n\t\t) {\n\t\t\tnewVNode._children = oldVNode._children;\n\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t} else {\n\t\t\tnewVNode._dom = diffElementNodes(\n\t\t\t\toldVNode._dom,\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\tisHydrating\n\t\t\t);\n\t\t}\n\n\t\tif ((tmp = options.diffed)) tmp(newVNode);\n\t} catch (e) {\n\t\tnewVNode._original = null;\n\t\t// if hydrating or creating initial tree, bailout preserves DOM:\n\t\tif (isHydrating || excessDomChildren != null) {\n\t\t\tnewVNode._dom = oldDom;\n\t\t\tnewVNode._hydrating = !!isHydrating;\n\t\t\texcessDomChildren[excessDomChildren.indexOf(oldDom)] = null;\n\t\t\t// ^ could possibly be simplified to:\n\t\t\t// excessDomChildren.length = 0;\n\t\t}\n\t\toptions._catchError(e, newVNode, oldVNode);\n\t}\n}\n\n/**\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {import('../internal').VNode} root\n */\nexport function commitRoot(commitQueue, root) {\n\tif (options._commit) options._commit(root, commitQueue);\n\n\tcommitQueue.some(c => {\n\t\ttry {\n\t\t\t// @ts-ignore Reuse the commitQueue variable here so the type changes\n\t\t\tcommitQueue = c._renderCallbacks;\n\t\t\tc._renderCallbacks = [];\n\t\t\tcommitQueue.some(cb => {\n\t\t\t\t// @ts-ignore See above ts-ignore on commitQueue\n\t\t\t\tcb.call(c);\n\t\t\t});\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t});\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {import('../internal').PreactElement} dom The DOM element representing\n * the virtual nodes being diffed\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\n * @param {*} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @returns {import('../internal').PreactElement}\n */\nfunction diffElementNodes(\n\tdom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\tisHydrating\n) {\n\tlet oldProps = oldVNode.props;\n\tlet newProps = newVNode.props;\n\tlet nodeType = newVNode.type;\n\tlet i = 0;\n\n\t// Tracks entering and exiting SVG namespace when descending through the tree.\n\tif (nodeType === 'svg') isSvg = true;\n\n\tif (excessDomChildren != null) {\n\t\tfor (; i < excessDomChildren.length; i++) {\n\t\t\tconst child = excessDomChildren[i];\n\n\t\t\t// if newVNode matches an element in excessDomChildren or the `dom`\n\t\t\t// argument matches an element in excessDomChildren, remove it from\n\t\t\t// excessDomChildren so it isn't later removed in diffChildren\n\t\t\tif (\n\t\t\t\tchild &&\n\t\t\t\t'setAttribute' in child === !!nodeType &&\n\t\t\t\t(nodeType ? child.localName === nodeType : child.nodeType === 3)\n\t\t\t) {\n\t\t\t\tdom = child;\n\t\t\t\texcessDomChildren[i] = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dom == null) {\n\t\tif (nodeType === null) {\n\t\t\t// @ts-ignore createTextNode returns Text, we expect PreactElement\n\t\t\treturn document.createTextNode(newProps);\n\t\t}\n\n\t\tif (isSvg) {\n\t\t\tdom = document.createElementNS(\n\t\t\t\t'http://www.w3.org/2000/svg',\n\t\t\t\t// @ts-ignore We know `newVNode.type` is a string\n\t\t\t\tnodeType\n\t\t\t);\n\t\t} else {\n\t\t\tdom = document.createElement(\n\t\t\t\t// @ts-ignore We know `newVNode.type` is a string\n\t\t\t\tnodeType,\n\t\t\t\tnewProps.is && newProps\n\t\t\t);\n\t\t}\n\n\t\t// we created a new parent, so none of the previously attached children can be reused:\n\t\texcessDomChildren = null;\n\t\t// we are creating a new node, so we can assume this is a new subtree (in case we are hydrating), this deopts the hydrate\n\t\tisHydrating = false;\n\t}\n\n\tif (nodeType === null) {\n\t\t// During hydration, we still have to split merged text from SSR'd HTML.\n\t\tif (oldProps !== newProps && (!isHydrating || dom.data !== newProps)) {\n\t\t\tdom.data = newProps;\n\t\t}\n\t} else {\n\t\t// If excessDomChildren was not null, repopulate it with the current element's children:\n\t\texcessDomChildren = excessDomChildren && slice.call(dom.childNodes);\n\n\t\toldProps = oldVNode.props || EMPTY_OBJ;\n\n\t\tlet oldHtml = oldProps.dangerouslySetInnerHTML;\n\t\tlet newHtml = newProps.dangerouslySetInnerHTML;\n\n\t\t// During hydration, props are not diffed at all (including dangerouslySetInnerHTML)\n\t\t// @TODO we should warn in debug mode when props don't match here.\n\t\tif (!isHydrating) {\n\t\t\t// But, if we are in a situation where we are using existing DOM (e.g. replaceNode)\n\t\t\t// we should read the existing DOM attributes to diff them\n\t\t\tif (excessDomChildren != null) {\n\t\t\t\toldProps = {};\n\t\t\t\tfor (i = 0; i < dom.attributes.length; i++) {\n\t\t\t\t\toldProps[dom.attributes[i].name] = dom.attributes[i].value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (newHtml || oldHtml) {\n\t\t\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\n\t\t\t\tif (\n\t\t\t\t\t!newHtml ||\n\t\t\t\t\t((!oldHtml || newHtml.__html != oldHtml.__html) &&\n\t\t\t\t\t\tnewHtml.__html !== dom.innerHTML)\n\t\t\t\t) {\n\t\t\t\t\tdom.innerHTML = (newHtml && newHtml.__html) || '';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdiffProps(dom, newProps, oldProps, isSvg, isHydrating);\n\n\t\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\t\tif (newHtml) {\n\t\t\tnewVNode._children = [];\n\t\t} else {\n\t\t\ti = newVNode.props.children;\n\t\t\tdiffChildren(\n\t\t\t\tdom,\n\t\t\t\tArray.isArray(i) ? i : [i],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg && nodeType !== 'foreignObject',\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\texcessDomChildren\n\t\t\t\t\t? excessDomChildren[0]\n\t\t\t\t\t: oldVNode._children && getDomSibling(oldVNode, 0),\n\t\t\t\tisHydrating\n\t\t\t);\n\n\t\t\t// Remove children that are not part of any vnode.\n\t\t\tif (excessDomChildren != null) {\n\t\t\t\tfor (i = excessDomChildren.length; i--; ) {\n\t\t\t\t\tif (excessDomChildren[i] != null) removeNode(excessDomChildren[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// (as above, don't diff props during hydration)\n\t\tif (!isHydrating) {\n\t\t\tif (\n\t\t\t\t'value' in newProps &&\n\t\t\t\t(i = newProps.value) !== undefined &&\n\t\t\t\t// #2756 For the <progress>-element the initial value is 0,\n\t\t\t\t// despite the attribute not being present. When the attribute\n\t\t\t\t// is missing the progress bar is treated as indeterminate.\n\t\t\t\t// To fix that we'll always update it when it is 0 for progress elements\n\t\t\t\t(i !== dom.value ||\n\t\t\t\t\t(nodeType === 'progress' && !i) ||\n\t\t\t\t\t// This is only for IE 11 to fix <select> value not being updated.\n\t\t\t\t\t// To avoid a stale select value we need to set the option.value\n\t\t\t\t\t// again, which triggers IE11 to re-evaluate the select value\n\t\t\t\t\t(nodeType === 'option' && i !== oldProps.value))\n\t\t\t) {\n\t\t\t\tsetProperty(dom, 'value', i, oldProps.value, false);\n\t\t\t}\n\t\t\tif (\n\t\t\t\t'checked' in newProps &&\n\t\t\t\t(i = newProps.checked) !== undefined &&\n\t\t\t\ti !== dom.checked\n\t\t\t) {\n\t\t\t\tsetProperty(dom, 'checked', i, oldProps.checked, false);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {object|function} ref\n * @param {any} value\n * @param {import('../internal').VNode} vnode\n */\nexport function applyRef(ref, value, vnode) {\n\ttry {\n\t\tif (typeof ref == 'function') ref(value);\n\t\telse ref.current = value;\n\t} catch (e) {\n\t\toptions._catchError(e, vnode);\n\t}\n}\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {import('../internal').VNode} vnode The virtual node to unmount\n * @param {import('../internal').VNode} parentVNode The parent of the VNode that\n * initiated the unmount\n * @param {boolean} [skipRemove] Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nexport function unmount(vnode, parentVNode, skipRemove) {\n\tlet r;\n\tif (options.unmount) options.unmount(vnode);\n\n\tif ((r = vnode.ref)) {\n\t\tif (!r.current || r.current === vnode._dom) {\n\t\t\tapplyRef(r, null, parentVNode);\n\t\t}\n\t}\n\n\tif ((r = vnode._component) != null) {\n\t\tif (r.componentWillUnmount) {\n\t\t\ttry {\n\t\t\t\tr.componentWillUnmount();\n\t\t\t} catch (e) {\n\t\t\t\toptions._catchError(e, parentVNode);\n\t\t\t}\n\t\t}\n\n\t\tr.base = r._parentDom = null;\n\t\tvnode._component = undefined;\n\t}\n\n\tif ((r = vnode._children)) {\n\t\tfor (let i = 0; i < r.length; i++) {\n\t\t\tif (r[i]) {\n\t\t\t\tunmount(\n\t\t\t\t\tr[i],\n\t\t\t\t\tparentVNode,\n\t\t\t\t\tskipRemove || typeof vnode.type !== 'function'\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!skipRemove && vnode._dom != null) {\n\t\tremoveNode(vnode._dom);\n\t}\n\n\t// Must be set to `undefined` to properly clean up `_nextDom`\n\t// for which `null` is a valid value. See comment in `create-element.js`\n\tvnode._parent = vnode._dom = vnode._nextDom = undefined;\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n","import { EMPTY_OBJ } from './constants';\nimport { commitRoot, diff } from './diff/index';\nimport { createElement, Fragment } from './create-element';\nimport options from './options';\nimport { slice } from './util';\n\n/**\n * Render a Preact virtual node into a DOM element\n * @param {import('./internal').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * render into\n * @param {import('./internal').PreactElement | object} [replaceNode] Optional: Attempt to re-use an\n * existing DOM tree rooted at `replaceNode`\n */\nexport function render(vnode, parentDom, replaceNode) {\n\tif (options._root) options._root(vnode, parentDom);\n\n\t// We abuse the `replaceNode` parameter in `hydrate()` to signal if we are in\n\t// hydration mode or not by passing the `hydrate` function instead of a DOM\n\t// element..\n\tlet isHydrating = typeof replaceNode === 'function';\n\n\t// To be able to support calling `render()` multiple times on the same\n\t// DOM node, we need to obtain a reference to the previous tree. We do\n\t// this by assigning a new `_children` property to DOM nodes which points\n\t// to the last rendered tree. By default this property is not present, which\n\t// means that we are mounting a new tree for the first time.\n\tlet oldVNode = isHydrating\n\t\t? null\n\t\t: (replaceNode && replaceNode._children) || parentDom._children;\n\n\tvnode = ((!isHydrating && replaceNode) || parentDom)._children =\n\t\tcreateElement(Fragment, null, [vnode]);\n\n\t// List of effects that need to be called after diffing.\n\tlet commitQueue = [];\n\tdiff(\n\t\tparentDom,\n\t\t// Determine the new vnode tree and store it on the DOM element on\n\t\t// our custom `_children` property.\n\t\tvnode,\n\t\toldVNode || EMPTY_OBJ,\n\t\tEMPTY_OBJ,\n\t\tparentDom.ownerSVGElement !== undefined,\n\t\t!isHydrating && replaceNode\n\t\t\t? [replaceNode]\n\t\t\t: oldVNode\n\t\t\t? null\n\t\t\t: parentDom.firstChild\n\t\t\t? slice.call(parentDom.childNodes)\n\t\t\t: null,\n\t\tcommitQueue,\n\t\t!isHydrating && replaceNode\n\t\t\t? replaceNode\n\t\t\t: oldVNode\n\t\t\t? oldVNode._dom\n\t\t\t: parentDom.firstChild,\n\t\tisHydrating\n\t);\n\n\t// Flush all queued effects\n\tcommitRoot(commitQueue, vnode);\n}\n\n/**\n * Update an existing DOM element with data from a Preact virtual node\n * @param {import('./internal').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * update\n */\nexport function hydrate(vnode, parentDom) {\n\trender(vnode, parentDom, hydrate);\n}\n","import { assign, slice } from './util';\nimport { createVNode } from './create-element';\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its children.\n * @param {import('./internal').VNode} vnode The virtual DOM element to clone\n * @param {object} props Attributes/props to add when cloning\n * @param {Array<import('./internal').ComponentChildren>} rest Any additional arguments will be used as replacement children.\n * @returns {import('./internal').VNode}\n */\nexport function cloneElement(vnode, props, children) {\n\tlet normalizedProps = assign({}, vnode.props),\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\treturn createVNode(\n\t\tvnode.type,\n\t\tnormalizedProps,\n\t\tkey || vnode.key,\n\t\tref || vnode.ref,\n\t\tnull\n\t);\n}\n","/**\n * Find the closest error boundary to a thrown error and call it\n * @param {object} error The thrown value\n * @param {import('../internal').VNode} vnode The vnode that threw\n * the error that was caught (except for unmounting when this parameter\n * is the highest parent that was being unmounted)\n * @param {import('../internal').VNode} [oldVNode]\n * @param {import('../internal').ErrorInfo} [errorInfo]\n */\nexport function _catchError(error, vnode, oldVNode, errorInfo) {\n\t/** @type {import('../internal').Component} */\n\tlet component, ctor, handled;\n\n\tfor (; (vnode = vnode._parent); ) {\n\t\tif ((component = vnode._component) && !component._processingException) {\n\t\t\ttry {\n\t\t\t\tctor = component.constructor;\n\n\t\t\t\tif (ctor && ctor.getDerivedStateFromError != null) {\n\t\t\t\t\tcomponent.setState(ctor.getDerivedStateFromError(error));\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\tif (component.componentDidCatch != null) {\n\t\t\t\t\tcomponent.componentDidCatch(error, errorInfo || {});\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\t// This is an error boundary. Mark it as having bailed out, and whether it was mid-hydration.\n\t\t\t\tif (handled) {\n\t\t\t\t\treturn (component._pendingError = component);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow error;\n}\n","import { options } from 'preact';\n\n/** @type {number} */\nlet currentIndex;\n\n/** @type {import('./internal').Component} */\nlet currentComponent;\n\n/** @type {import('./internal').Component} */\nlet previousComponent;\n\n/** @type {number} */\nlet currentHook = 0;\n\n/** @type {Array<import('./internal').Component>} */\nlet afterPaintEffects = [];\n\nlet EMPTY = [];\n\nlet oldBeforeDiff = options._diff;\nlet oldBeforeRender = options._render;\nlet oldAfterDiff = options.diffed;\nlet oldCommit = options._commit;\nlet oldBeforeUnmount = options.unmount;\n\nconst RAF_TIMEOUT = 100;\nlet prevRaf;\n\noptions._diff = vnode => {\n\tcurrentComponent = null;\n\tif (oldBeforeDiff) oldBeforeDiff(vnode);\n};\n\noptions._render = vnode => {\n\tif (oldBeforeRender) oldBeforeRender(vnode);\n\n\tcurrentComponent = vnode._component;\n\tcurrentIndex = 0;\n\n\tconst hooks = currentComponent.__hooks;\n\tif (hooks) {\n\t\tif (previousComponent === currentComponent) {\n\t\t\thooks._pendingEffects = [];\n\t\t\tcurrentComponent._renderCallbacks = [];\n\t\t\thooks._list.forEach(hookItem => {\n\t\t\t\tif (hookItem._nextValue) {\n\t\t\t\t\thookItem._value = hookItem._nextValue;\n\t\t\t\t}\n\t\t\t\thookItem._pendingValue = EMPTY;\n\t\t\t\thookItem._nextValue = hookItem._pendingArgs = undefined;\n\t\t\t});\n\t\t} else {\n\t\t\thooks._pendingEffects.forEach(invokeCleanup);\n\t\t\thooks._pendingEffects.forEach(invokeEffect);\n\t\t\thooks._pendingEffects = [];\n\t\t}\n\t}\n\tpreviousComponent = currentComponent;\n};\n\noptions.diffed = vnode => {\n\tif (oldAfterDiff) oldAfterDiff(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks) {\n\t\tif (c.__hooks._pendingEffects.length) afterPaint(afterPaintEffects.push(c));\n\t\tc.__hooks._list.forEach(hookItem => {\n\t\t\tif (hookItem._pendingArgs) {\n\t\t\t\thookItem._args = hookItem._pendingArgs;\n\t\t\t}\n\t\t\tif (hookItem._pendingValue !== EMPTY) {\n\t\t\t\thookItem._value = hookItem._pendingValue;\n\t\t\t}\n\t\t\thookItem._pendingArgs = undefined;\n\t\t\thookItem._pendingValue = EMPTY;\n\t\t});\n\t}\n\tpreviousComponent = currentComponent = null;\n};\n\noptions._commit = (vnode, commitQueue) => {\n\tcommitQueue.some(component => {\n\t\ttry {\n\t\t\tcomponent._renderCallbacks.forEach(invokeCleanup);\n\t\t\tcomponent._renderCallbacks = component._renderCallbacks.filter(cb =>\n\t\t\t\tcb._value ? invokeEffect(cb) : true\n\t\t\t);\n\t\t} catch (e) {\n\t\t\tcommitQueue.some(c => {\n\t\t\t\tif (c._renderCallbacks) c._renderCallbacks = [];\n\t\t\t});\n\t\t\tcommitQueue = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t});\n\n\tif (oldCommit) oldCommit(vnode, commitQueue);\n};\n\noptions.unmount = vnode => {\n\tif (oldBeforeUnmount) oldBeforeUnmount(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks) {\n\t\tlet hasErrored;\n\t\tc.__hooks._list.forEach(s => {\n\t\t\ttry {\n\t\t\t\tinvokeCleanup(s);\n\t\t\t} catch (e) {\n\t\t\t\thasErrored = e;\n\t\t\t}\n\t\t});\n\t\tc.__hooks = undefined;\n\t\tif (hasErrored) options._catchError(hasErrored, c._vnode);\n\t}\n};\n\n/**\n * Get a hook's state from the currentComponent\n * @param {number} index The index of the hook to get\n * @param {number} type The index of the hook to get\n * @returns {any}\n */\nfunction getHookState(index, type) {\n\tif (options._hook) {\n\t\toptions._hook(currentComponent, index, currentHook || type);\n\t}\n\tcurrentHook = 0;\n\n\t// Largely inspired by:\n\t// * https://github.com/michael-klein/funcy.js/blob/f6be73468e6ec46b0ff5aa3cc4c9baf72a29025a/src/hooks/core_hooks.mjs\n\t// * https://github.com/michael-klein/funcy.js/blob/650beaa58c43c33a74820a3c98b3c7079cf2e333/src/renderer.mjs\n\t// Other implementations to look at:\n\t// * https://codesandbox.io/s/mnox05qp8\n\tconst hooks =\n\t\tcurrentComponent.__hooks ||\n\t\t(currentComponent.__hooks = {\n\t\t\t_list: [],\n\t\t\t_pendingEffects: []\n\t\t});\n\n\tif (index >= hooks._list.length) {\n\t\thooks._list.push({ _pendingValue: EMPTY });\n\t}\n\treturn hooks._list[index];\n}\n\n/**\n * @param {import('./index').StateUpdater<any>} [initialState]\n */\nexport function useState(initialState) {\n\tcurrentHook = 1;\n\treturn useReducer(invokeOrReturn, initialState);\n}\n\n/**\n * @param {import('./index').Reducer<any, any>} reducer\n * @param {import('./index').StateUpdater<any>} initialState\n * @param {(initialState: any) => void} [init]\n * @returns {[ any, (state: any) => void ]}\n */\nexport function useReducer(reducer, initialState, init) {\n\t/** @type {import('./internal').ReducerHookState} */\n\tconst hookState = getHookState(currentIndex++, 2);\n\thookState._reducer = reducer;\n\tif (!hookState._component) {\n\t\thookState._value = [\n\t\t\t!init ? invokeOrReturn(undefined, initialState) : init(initialState),\n\n\t\t\taction => {\n\t\t\t\tconst currentValue = hookState._nextValue\n\t\t\t\t\t? hookState._nextValue[0]\n\t\t\t\t\t: hookState._value[0];\n\t\t\t\tconst nextValue = hookState._reducer(currentValue, action);\n\n\t\t\t\tif (currentValue !== nextValue) {\n\t\t\t\t\thookState._nextValue = [nextValue, hookState._value[1]];\n\t\t\t\t\thookState._component.setState({});\n\t\t\t\t}\n\t\t\t}\n\t\t];\n\n\t\thookState._component = currentComponent;\n\n\t\tif (!currentComponent._hasScuFromHooks) {\n\t\t\tcurrentComponent._hasScuFromHooks = true;\n\t\t\tlet prevScu = currentComponent.shouldComponentUpdate;\n\t\t\tconst prevCWU = currentComponent.componentWillUpdate;\n\n\t\t\t// If we're dealing with a forced update `shouldComponentUpdate` will\n\t\t\t// not be called. But we use that to update the hook values, so we\n\t\t\t// need to call it.\n\t\t\tcurrentComponent.componentWillUpdate = function (p, s, c) {\n\t\t\t\tif (this._force) {\n\t\t\t\t\tlet tmp = prevScu;\n\t\t\t\t\t// Clear to avoid other sCU hooks from being called\n\t\t\t\t\tprevScu = undefined;\n\t\t\t\t\tupdateHookState(p, s, c);\n\t\t\t\t\tprevScu = tmp;\n\t\t\t\t}\n\n\t\t\t\tif (prevCWU) prevCWU.call(this, p, s, c);\n\t\t\t};\n\n\t\t\t// This SCU has the purpose of bailing out after repeated updates\n\t\t\t// to stateful hooks.\n\t\t\t// we store the next value in _nextValue[0] and keep doing that for all\n\t\t\t// state setters, if we have next states and\n\t\t\t// all next states within a component end up being equal to their original state\n\t\t\t// we are safe to bail out for this specific component.\n\t\t\t/**\n\t\t\t *\n\t\t\t * @type {import('./internal').Component[\"shouldComponentUpdate\"]}\n\t\t\t */\n\t\t\t// @ts-ignore - We don't use TS to downtranspile\n\t\t\t// eslint-disable-next-line no-inner-declarations\n\t\t\tfunction updateHookState(p, s, c) {\n\t\t\t\tif (!hookState._component.__hooks) return true;\n\n\t\t\t\tconst stateHooks = hookState._component.__hooks._list.filter(\n\t\t\t\t\tx => x._component\n\t\t\t\t);\n\t\t\t\tconst allHooksEmpty = stateHooks.every(x => !x._nextValue);\n\t\t\t\t// When we have no updated hooks in the component we invoke the previous SCU or\n\t\t\t\t// traverse the VDOM tree further.\n\t\t\t\tif (allHooksEmpty) {\n\t\t\t\t\treturn prevScu ? prevScu.call(this, p, s, c) : true;\n\t\t\t\t}\n\n\t\t\t\t// We check whether we have components with a nextValue set that\n\t\t\t\t// have values that aren't equal to one another this pushes\n\t\t\t\t// us to update further down the tree\n\t\t\t\tlet shouldUpdate = false;\n\t\t\t\tstateHooks.forEach(hookItem => {\n\t\t\t\t\tif (hookItem._nextValue) {\n\t\t\t\t\t\tconst currentValue = hookItem._value[0];\n\t\t\t\t\t\thookItem._value = hookItem._nextValue;\n\t\t\t\t\t\thookItem._nextValue = undefined;\n\t\t\t\t\t\tif (currentValue !== hookItem._value[0]) shouldUpdate = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn shouldUpdate || hookState._component.props !== p\n\t\t\t\t\t? prevScu\n\t\t\t\t\t\t? prevScu.call(this, p, s, c)\n\t\t\t\t\t\t: true\n\t\t\t\t\t: false;\n\t\t\t}\n\n\t\t\tcurrentComponent.shouldComponentUpdate = updateHookState;\n\t\t}\n\t}\n\n\treturn hookState._nextValue || hookState._value;\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {any[]} args\n */\nexport function useEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 3);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._pendingArgs = args;\n\n\t\tcurrentComponent.__hooks._pendingEffects.push(state);\n\t}\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {any[]} args\n */\nexport function useLayoutEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 4);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._pendingArgs = args;\n\n\t\tcurrentComponent._renderCallbacks.push(state);\n\t}\n}\n\nexport function useRef(initialValue) {\n\tcurrentHook = 5;\n\treturn useMemo(() => ({ current: initialValue }), []);\n}\n\n/**\n * @param {object} ref\n * @param {() => object} createHandle\n * @param {any[]} args\n */\nexport function useImperativeHandle(ref, createHandle, args) {\n\tcurrentHook = 6;\n\tuseLayoutEffect(\n\t\t() => {\n\t\t\tif (typeof ref == 'function') {\n\t\t\t\tref(createHandle());\n\t\t\t\treturn () => ref(null);\n\t\t\t} else if (ref) {\n\t\t\t\tref.current = createHandle();\n\t\t\t\treturn () => (ref.current = null);\n\t\t\t}\n\t\t},\n\t\targs == null ? args : args.concat(ref)\n\t);\n}\n\n/**\n * @param {() => any} factory\n * @param {any[]} args\n */\nexport function useMemo(factory, args) {\n\t/** @type {import('./internal').MemoHookState} */\n\tconst state = getHookState(currentIndex++, 7);\n\tif (argsChanged(state._args, args)) {\n\t\tstate._pendingValue = factory();\n\t\tstate._pendingArgs = args;\n\t\tstate._factory = factory;\n\t\treturn state._pendingValue;\n\t}\n\n\treturn state._value;\n}\n\n/**\n * @param {() => void} callback\n * @param {any[]} args\n */\nexport function useCallback(callback, args) {\n\tcurrentHook = 8;\n\treturn useMemo(() => callback, args);\n}\n\n/**\n * @param {import('./internal').PreactContext} context\n */\nexport function useContext(context) {\n\tconst provider = currentComponent.context[context._id];\n\t// We could skip this call here, but than we'd not call\n\t// `options._hook`. We need to do that in order to make\n\t// the devtools aware of this hook.\n\t/** @type {import('./internal').ContextHookState} */\n\tconst state = getHookState(currentIndex++, 9);\n\t// The devtools needs access to the context object to\n\t// be able to pull of the default value when no provider\n\t// is present in the tree.\n\tstate._context = context;\n\tif (!provider) return context._defaultValue;\n\t// This is probably not safe to convert to \"!\"\n\tif (state._value == null) {\n\t\tstate._value = true;\n\t\tprovider.sub(currentComponent);\n\t}\n\treturn provider.props.value;\n}\n\n/**\n * Display a custom label for a custom hook for the devtools panel\n * @type {<T>(value: T, cb?: (value: T) => string | number) => void}\n */\nexport function useDebugValue(value, formatter) {\n\tif (options.useDebugValue) {\n\t\toptions.useDebugValue(formatter ? formatter(value) : value);\n\t}\n}\n\n/**\n * @param {(error: any, errorInfo: import('preact').ErrorInfo) => void} cb\n */\nexport function useErrorBoundary(cb) {\n\t/** @type {import('./internal').ErrorBoundaryHookState} */\n\tconst state = getHookState(currentIndex++, 10);\n\tconst errState = useState();\n\tstate._value = cb;\n\tif (!currentComponent.componentDidCatch) {\n\t\tcurrentComponent.componentDidCatch = (err, errorInfo) => {\n\t\t\tif (state._value) state._value(err, errorInfo);\n\t\t\terrState[1](err);\n\t\t};\n\t}\n\treturn [\n\t\terrState[0],\n\t\t() => {\n\t\t\terrState[1](undefined);\n\t\t}\n\t];\n}\n\nexport function useId() {\n\tconst state = getHookState(currentIndex++, 11);\n\tif (!state._value) {\n\t\t// Grab either the root node or the nearest async boundary node.\n\t\t/** @type {import('./internal.d').VNode} */\n\t\tlet root = currentComponent._vnode;\n\t\twhile (root !== null && !root._mask && root._parent !== null) {\n\t\t\troot = root._parent;\n\t\t}\n\n\t\tlet mask = root._mask || (root._mask = [0, 0]);\n\t\tstate._value = 'P' + mask[0] + '-' + mask[1]++;\n\t}\n\n\treturn state._value;\n}\n/**\n * After paint effects consumer.\n */\nfunction flushAfterPaintEffects() {\n\tlet component;\n\twhile ((component = afterPaintEffects.shift())) {\n\t\tif (!component._parentDom || !component.__hooks) continue;\n\t\ttry {\n\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeCleanup);\n\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeEffect);\n\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t} catch (e) {\n\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t}\n}\n\nlet HAS_RAF = typeof requestAnimationFrame == 'function';\n\n/**\n * Schedule a callback to be invoked after the browser has a chance to paint a new frame.\n * Do this by combining requestAnimationFrame (rAF) + setTimeout to invoke a callback after\n * the next browser frame.\n *\n * Also, schedule a timeout in parallel to the the rAF to ensure the callback is invoked\n * even if RAF doesn't fire (for example if the browser tab is not visible)\n *\n * @param {() => void} callback\n */\nfunction afterNextFrame(callback) {\n\tconst done = () => {\n\t\tclearTimeout(timeout);\n\t\tif (HAS_RAF) cancelAnimationFrame(raf);\n\t\tsetTimeout(callback);\n\t};\n\tconst timeout = setTimeout(done, RAF_TIMEOUT);\n\n\tlet raf;\n\tif (HAS_RAF) {\n\t\traf = requestAnimationFrame(done);\n\t}\n}\n\n// Note: if someone used options.debounceRendering = requestAnimationFrame,\n// then effects will ALWAYS run on the NEXT frame instead of the current one, incurring a ~16ms delay.\n// Perhaps this is not such a big deal.\n/**\n * Schedule afterPaintEffects flush after the browser paints\n * @param {number} newQueueLength\n */\nfunction afterPaint(newQueueLength) {\n\tif (newQueueLength === 1 || prevRaf !== options.requestAnimationFrame) {\n\t\tprevRaf = options.requestAnimationFrame;\n\t\t(prevRaf || afterNextFrame)(flushAfterPaintEffects);\n\t}\n}\n\n/**\n * @param {import('./internal').EffectHookState} hook\n */\nfunction invokeCleanup(hook) {\n\t// A hook cleanup can introduce a call to render which creates a new root, this will call options.vnode\n\t// and move the currentComponent away.\n\tconst comp = currentComponent;\n\tlet cleanup = hook._cleanup;\n\tif (typeof cleanup == 'function') {\n\t\thook._cleanup = undefined;\n\t\tcleanup();\n\t}\n\n\tcurrentComponent = comp;\n}\n\n/**\n * Invoke a Hook's effect\n * @param {import('./internal').EffectHookState} hook\n */\nfunction invokeEffect(hook) {\n\t// A hook call can introduce a call to render which creates a new root, this will call options.vnode\n\t// and move the currentComponent away.\n\tconst comp = currentComponent;\n\thook._cleanup = hook._value();\n\tcurrentComponent = comp;\n}\n\n/**\n * @param {any[]} oldArgs\n * @param {any[]} newArgs\n */\nfunction argsChanged(oldArgs, newArgs) {\n\treturn (\n\t\t!oldArgs ||\n\t\toldArgs.length !== newArgs.length ||\n\t\tnewArgs.some((arg, index) => arg !== oldArgs[index])\n\t);\n}\n\nfunction invokeOrReturn(arg, f) {\n\treturn typeof f == 'function' ? f(arg) : f;\n}\n","/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Check if two objects have a different shape\n * @param {object} a\n * @param {object} b\n * @returns {boolean}\n */\nexport function shallowDiffers(a, b) {\n\tfor (let i in a) if (i !== '__source' && !(i in b)) return true;\n\tfor (let i in b) if (i !== '__source' && a[i] !== b[i]) return true;\n\treturn false;\n}\n\nexport function removeNode(node) {\n\tlet parentNode = node.parentNode;\n\tif (parentNode) parentNode.removeChild(node);\n}\n\n/**\n * Check if two values are the same value\n * @param {*} x\n * @param {*} y\n * @returns {boolean}\n */\nexport function is(x, y) {\n\treturn (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y);\n}\n","import { Component } from 'preact';\nimport { shallowDiffers } from './util';\n\n/**\n * Component class with a predefined `shouldComponentUpdate` implementation\n */\nexport function PureComponent(p) {\n\tthis.props = p;\n}\nPureComponent.prototype = new Component();\n// Some third-party libraries check if this property is present\nPureComponent.prototype.isPureReactComponent = true;\nPureComponent.prototype.shouldComponentUpdate = function (props, state) {\n\treturn shallowDiffers(this.props, props) || shallowDiffers(this.state, state);\n};\n","import { createElement } from 'preact';\nimport { shallowDiffers } from './util';\n\n/**\n * Memoize a component, so that it only updates when the props actually have\n * changed. This was previously known as `React.pure`.\n * @param {import('./internal').FunctionComponent} c functional component\n * @param {(prev: object, next: object) => boolean} [comparer] Custom equality function\n * @returns {import('./internal').FunctionComponent}\n */\nexport function memo(c, comparer) {\n\tfunction shouldUpdate(nextProps) {\n\t\tlet ref = this.props.ref;\n\t\tlet updateRef = ref == nextProps.ref;\n\t\tif (!updateRef && ref) {\n\t\t\tref.call ? ref(null) : (ref.current = null);\n\t\t}\n\n\t\tif (!comparer) {\n\t\t\treturn shallowDiffers(this.props, nextProps);\n\t\t}\n\n\t\treturn !comparer(this.props, nextProps) || !updateRef;\n\t}\n\n\tfunction Memoed(props) {\n\t\tthis.shouldComponentUpdate = shouldUpdate;\n\t\treturn createElement(c, props);\n\t}\n\tMemoed.displayName = 'Memo(' + (c.displayName || c.name) + ')';\n\tMemoed.prototype.isReactComponent = true;\n\tMemoed._forwarded = true;\n\treturn Memoed;\n}\n","import { options } from 'preact';\nimport { assign } from './util';\n\nlet oldDiffHook = options._diff;\noptions._diff = vnode => {\n\tif (vnode.type && vnode.type._forwarded && vnode.ref) {\n\t\tvnode.props.ref = vnode.ref;\n\t\tvnode.ref = null;\n\t}\n\tif (oldDiffHook) oldDiffHook(vnode);\n};\n\nexport const REACT_FORWARD_SYMBOL =\n\t(typeof Symbol != 'undefined' &&\n\t\tSymbol.for &&\n\t\tSymbol.for('react.forward_ref')) ||\n\t0xf47;\n\n/**\n * Pass ref down to a child. This is mainly used in libraries with HOCs that\n * wrap components. Using `forwardRef` there is an easy way to get a reference\n * of the wrapped component instead of one of the wrapper itself.\n * @param {import('./index').ForwardFn} fn\n * @returns {import('./internal').FunctionComponent}\n */\nexport function forwardRef(fn) {\n\tfunction Forwarded(props) {\n\t\tlet clone = assign({}, props);\n\t\tdelete clone.ref;\n\t\treturn fn(clone, props.ref || null);\n\t}\n\n\t// mobx-react checks for this being present\n\tForwarded.$$typeof = REACT_FORWARD_SYMBOL;\n\t// mobx-react heavily relies on implementation details.\n\t// It expects an object here with a `render` property,\n\t// and prototype.render will fail. Without this\n\t// mobx-react throws.\n\tForwarded.render = Forwarded;\n\n\tForwarded.prototype.isReactComponent = Forwarded._forwarded = true;\n\tForwarded.displayName = 'ForwardRef(' + (fn.displayName || fn.name) + ')';\n\treturn Forwarded;\n}\n","import { toChildArray } from 'preact';\n\nconst mapFn = (children, fn) => {\n\tif (children == null) return null;\n\treturn toChildArray(toChildArray(children).map(fn));\n};\n\n// This API is completely unnecessary for Preact, so it's basically passthrough.\nexport const Children = {\n\tmap: mapFn,\n\tforEach: mapFn,\n\tcount(children) {\n\t\treturn children ? toChildArray(children).length : 0;\n\t},\n\tonly(children) {\n\t\tconst normalized = toChildArray(children);\n\t\tif (normalized.length !== 1) throw 'Children.only';\n\t\treturn normalized[0];\n\t},\n\ttoArray: toChildArray\n};\n","import { Component, createElement, options, Fragment } from 'preact';\nimport { assign } from './util';\n\nconst oldCatchError = options._catchError;\noptions._catchError = function (error, newVNode, oldVNode, errorInfo) {\n\tif (error.then) {\n\t\t/** @type {import('./internal').Component} */\n\t\tlet component;\n\t\tlet vnode = newVNode;\n\n\t\tfor (; (vnode = vnode._parent); ) {\n\t\t\tif ((component = vnode._component) && component._childDidSuspend) {\n\t\t\t\tif (newVNode._dom == null) {\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t}\n\t\t\t\t// Don't call oldCatchError if we found a Suspense\n\t\t\t\treturn component._childDidSuspend(error, newVNode);\n\t\t\t}\n\t\t}\n\t}\n\toldCatchError(error, newVNode, oldVNode, errorInfo);\n};\n\nconst oldUnmount = options.unmount;\noptions.unmount = function (vnode) {\n\t/** @type {import('./internal').Component} */\n\tconst component = vnode._component;\n\tif (component && component._onResolve) {\n\t\tcomponent._onResolve();\n\t}\n\n\t// if the component is still hydrating\n\t// most likely it is because the component is suspended\n\t// we set the vnode.type as `null` so that it is not a typeof function\n\t// so the unmount will remove the vnode._dom\n\tif (component && vnode._hydrating === true) {\n\t\tvnode.type = null;\n\t}\n\n\tif (oldUnmount) oldUnmount(vnode);\n};\n\nfunction detachedClone(vnode, detachedParent, parentDom) {\n\tif (vnode) {\n\t\tif (vnode._component && vnode._component.__hooks) {\n\t\t\tvnode._component.__hooks._list.forEach(effect => {\n\t\t\t\tif (typeof effect._cleanup == 'function') effect._cleanup();\n\t\t\t});\n\n\t\t\tvnode._component.__hooks = null;\n\t\t}\n\n\t\tvnode = assign({}, vnode);\n\t\tif (vnode._component != null) {\n\t\t\tif (vnode._component._parentDom === parentDom) {\n\t\t\t\tvnode._component._parentDom = detachedParent;\n\t\t\t}\n\t\t\tvnode._component = null;\n\t\t}\n\n\t\tvnode._children =\n\t\t\tvnode._children &&\n\t\t\tvnode._children.map(child =>\n\t\t\t\tdetachedClone(child, detachedParent, parentDom)\n\t\t\t);\n\t}\n\n\treturn vnode;\n}\n\nfunction removeOriginal(vnode, detachedParent, originalParent) {\n\tif (vnode) {\n\t\tvnode._original = null;\n\t\tvnode._children =\n\t\t\tvnode._children &&\n\t\t\tvnode._children.map(child =>\n\t\t\t\tremoveOriginal(child, detachedParent, originalParent)\n\t\t\t);\n\n\t\tif (vnode._component) {\n\t\t\tif (vnode._component._parentDom === detachedParent) {\n\t\t\t\tif (vnode._dom) {\n\t\t\t\t\toriginalParent.insertBefore(vnode._dom, vnode._nextDom);\n\t\t\t\t}\n\t\t\t\tvnode._component._force = true;\n\t\t\t\tvnode._component._parentDom = originalParent;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn vnode;\n}\n\n// having custom inheritance instead of a class here saves a lot of bytes\nexport function Suspense() {\n\t// we do not call super here to golf some bytes...\n\tthis._pendingSuspensionCount = 0;\n\tthis._suspenders = null;\n\tthis._detachOnNextRender = null;\n}\n\n// Things we do here to save some bytes but are not proper JS inheritance:\n// - call `new Component()` as the prototype\n// - do not set `Suspense.prototype.constructor` to `Suspense`\nSuspense.prototype = new Component();\n\n/**\n * @this {import('./internal').SuspenseComponent}\n * @param {Promise} promise The thrown promise\n * @param {import('./internal').VNode<any, any>} suspendingVNode The suspending component\n */\nSuspense.prototype._childDidSuspend = function (promise, suspendingVNode) {\n\tconst suspendingComponent = suspendingVNode._component;\n\n\t/** @type {import('./internal').SuspenseComponent} */\n\tconst c = this;\n\n\tif (c._suspenders == null) {\n\t\tc._suspenders = [];\n\t}\n\tc._suspenders.push(suspendingComponent);\n\n\tconst resolve = suspended(c._vnode);\n\n\tlet resolved = false;\n\tconst onResolved = () => {\n\t\tif (resolved) return;\n\n\t\tresolved = true;\n\t\tsuspendingComponent._onResolve = null;\n\n\t\tif (resolve) {\n\t\t\tresolve(onSuspensionComplete);\n\t\t} else {\n\t\t\tonSuspensionComplete();\n\t\t}\n\t};\n\n\tsuspendingComponent._onResolve = onResolved;\n\n\tconst onSuspensionComplete = () => {\n\t\tif (!--c._pendingSuspensionCount) {\n\t\t\t// If the suspension was during hydration we don't need to restore the\n\t\t\t// suspended children into the _children array\n\t\t\tif (c.state._suspended) {\n\t\t\t\tconst suspendedVNode = c.state._suspended;\n\t\t\t\tc._vnode._children[0] = removeOriginal(\n\t\t\t\t\tsuspendedVNode,\n\t\t\t\t\tsuspendedVNode._component._parentDom,\n\t\t\t\t\tsuspendedVNode._component._originalParentDom\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tc.setState({ _suspended: (c._detachOnNextRender = null) });\n\n\t\t\tlet suspended;\n\t\t\twhile ((suspended = c._suspenders.pop())) {\n\t\t\t\tsuspended.forceUpdate();\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * We do not set `suspended: true` during hydration because we want the actual markup\n\t * to remain on screen and hydrate it when the suspense actually gets resolved.\n\t * While in non-hydration cases the usual fallback -> component flow would occour.\n\t */\n\tconst wasHydrating = suspendingVNode._hydrating === true;\n\tif (!c._pendingSuspensionCount++ && !wasHydrating) {\n\t\tc.setState({ _suspended: (c._detachOnNextRender = c._vnode._children[0]) });\n\t}\n\tpromise.then(onResolved, onResolved);\n};\n\nSuspense.prototype.componentWillUnmount = function () {\n\tthis._suspenders = [];\n};\n\n/**\n * @this {import('./internal').SuspenseComponent}\n * @param {import('./internal').SuspenseComponent[\"props\"]} props\n * @param {import('./internal').SuspenseState} state\n */\nSuspense.prototype.render = function (props, state) {\n\tif (this._detachOnNextRender) {\n\t\t// When the Suspense's _vnode was created by a call to createVNode\n\t\t// (i.e. due to a setState further up in the tree)\n\t\t// it's _children prop is null, in this case we \"forget\" about the parked vnodes to detach\n\t\tif (this._vnode._children) {\n\t\t\tconst detachedParent = document.createElement('div');\n\t\t\tconst detachedComponent = this._vnode._children[0]._component;\n\t\t\tthis._vnode._children[0] = detachedClone(\n\t\t\t\tthis._detachOnNextRender,\n\t\t\t\tdetachedParent,\n\t\t\t\t(detachedComponent._originalParentDom = detachedComponent._parentDom)\n\t\t\t);\n\t\t}\n\n\t\tthis._detachOnNextRender = null;\n\t}\n\n\t// Wrap fallback tree in a VNode that prevents itself from being marked as aborting mid-hydration:\n\t/** @type {import('./internal').VNode} */\n\tconst fallback =\n\t\tstate._suspended && createElement(Fragment, null, props.fallback);\n\tif (fallback) fallback._hydrating = null;\n\n\treturn [\n\t\tcreateElement(Fragment, null, state._suspended ? null : props.children),\n\t\tfallback\n\t];\n};\n\n/**\n * Checks and calls the parent component's _suspended method, passing in the\n * suspended vnode. This is a way for a parent (e.g. SuspenseList) to get notified\n * that one of its children/descendants suspended.\n *\n * The parent MAY return a callback. The callback will get called when the\n * suspension resolves, notifying the parent of the fact.\n * Moreover, the callback gets function `unsuspend` as a parameter. The resolved\n * child descendant will not actually get unsuspended until `unsuspend` gets called.\n * This is a way for the parent to delay unsuspending.\n *\n * If the parent does not return a callback then the resolved vnode\n * gets unsuspended immediately when it resolves.\n *\n * @param {import('./internal').VNode} vnode\n * @returns {((unsuspend: () => void) => void)?}\n */\nexport function suspended(vnode) {\n\t/** @type {import('./internal').Component} */\n\tlet component = vnode._parent._component;\n\treturn component && component._suspended && component._suspended(vnode);\n}\n\nexport function lazy(loader) {\n\tlet prom;\n\tlet component;\n\tlet error;\n\n\tfunction Lazy(props) {\n\t\tif (!prom) {\n\t\t\tprom = loader();\n\t\t\tprom.then(\n\t\t\t\texports => {\n\t\t\t\t\tcomponent = exports.default || exports;\n\t\t\t\t},\n\t\t\t\te => {\n\t\t\t\t\terror = e;\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\tif (!component) {\n\t\t\tthrow prom;\n\t\t}\n\n\t\treturn createElement(component, props);\n\t}\n\n\tLazy.displayName = 'Lazy';\n\tLazy._forwarded = true;\n\treturn Lazy;\n}\n","import { Component, toChildArray } from 'preact';\nimport { suspended } from './suspense.js';\n\n// Indexes to linked list nodes (nodes are stored as arrays to save bytes).\nconst SUSPENDED_COUNT = 0;\nconst RESOLVED_COUNT = 1;\nconst NEXT_NODE = 2;\n\n// Having custom inheritance instead of a class here saves a lot of bytes.\nexport function SuspenseList() {\n\tthis._next = null;\n\tthis._map = null;\n}\n\n// Mark one of child's earlier suspensions as resolved.\n// Some pending callbacks may become callable due to this\n// (e.g. the last suspended descendant gets resolved when\n// revealOrder === 'together'). Process those callbacks as well.\nconst resolve = (list, child, node) => {\n\tif (++node[RESOLVED_COUNT] === node[SUSPENDED_COUNT]) {\n\t\t// The number a child (or any of its descendants) has been suspended\n\t\t// matches the number of times it's been resolved. Therefore we\n\t\t// mark the child as completely resolved by deleting it from ._map.\n\t\t// This is used to figure out when *all* children have been completely\n\t\t// resolved when revealOrder is 'together'.\n\t\tlist._map.delete(child);\n\t}\n\n\t// If revealOrder is falsy then we can do an early exit, as the\n\t// callbacks won't get queued in the node anyway.\n\t// If revealOrder is 'together' then also do an early exit\n\t// if all suspended descendants have not yet been resolved.\n\tif (\n\t\t!list.props.revealOrder ||\n\t\t(list.props.revealOrder[0] === 't' && list._map.size)\n\t) {\n\t\treturn;\n\t}\n\n\t// Walk the currently suspended children in order, calling their\n\t// stored callbacks on the way. Stop if we encounter a child that\n\t// has not been completely resolved yet.\n\tnode = list._next;\n\twhile (node) {\n\t\twhile (node.length > 3) {\n\t\t\tnode.pop()();\n\t\t}\n\t\tif (node[RESOLVED_COUNT] < node[SUSPENDED_COUNT]) {\n\t\t\tbreak;\n\t\t}\n\t\tlist._next = node = node[NEXT_NODE];\n\t}\n};\n\n// Things we do here to save some bytes but are not proper JS inheritance:\n// - call `new Component()` as the prototype\n// - do not set `Suspense.prototype.constructor` to `Suspense`\nSuspenseList.prototype = new Component();\n\nSuspenseList.prototype._suspended = function (child) {\n\tconst list = this;\n\tconst delegated = suspended(list._vnode);\n\n\tlet node = list._map.get(child);\n\tnode[SUSPENDED_COUNT]++;\n\n\treturn unsuspend => {\n\t\tconst wrappedUnsuspend = () => {\n\t\t\tif (!list.props.revealOrder) {\n\t\t\t\t// Special case the undefined (falsy) revealOrder, as there\n\t\t\t\t// is no need to coordinate a specific order or unsuspends.\n\t\t\t\tunsuspend();\n\t\t\t} else {\n\t\t\t\tnode.push(unsuspend);\n\t\t\t\tresolve(list, child, node);\n\t\t\t}\n\t\t};\n\t\tif (delegated) {\n\t\t\tdelegated(wrappedUnsuspend);\n\t\t} else {\n\t\t\twrappedUnsuspend();\n\t\t}\n\t};\n};\n\nSuspenseList.prototype.render = function (props) {\n\tthis._next = null;\n\tthis._map = new Map();\n\n\tconst children = toChildArray(props.children);\n\tif (props.revealOrder && props.revealOrder[0] === 'b') {\n\t\t// If order === 'backwards' (or, well, anything starting with a 'b')\n\t\t// then flip the child list around so that the last child will be\n\t\t// the first in the linked list.\n\t\tchildren.reverse();\n\t}\n\t// Build the linked list. Iterate through the children in reverse order\n\t// so that `_next` points to the first linked list node to be resolved.\n\tfor (let i = children.length; i--; ) {\n\t\t// Create a new linked list node as an array of form:\n\t\t// \t[suspended_count, resolved_count, next_node]\n\t\t// where suspended_count and resolved_count are numeric counters for\n\t\t// keeping track how many times a node has been suspended and resolved.\n\t\t//\n\t\t// Note that suspended_count starts from 1 instead of 0, so we can block\n\t\t// processing callbacks until componentDidMount has been called. In a sense\n\t\t// node is suspended at least until componentDidMount gets called!\n\t\t//\n\t\t// Pending callbacks are added to the end of the node:\n\t\t// \t[suspended_count, resolved_count, next_node, callback_0, callback_1, ...]\n\t\tthis._map.set(children[i], (this._next = [1, 0, this._next]));\n\t}\n\treturn props.children;\n};\n\nSuspenseList.prototype.componentDidUpdate =\n\tSuspenseList.prototype.componentDidMount = function () {\n\t\t// Iterate through all children after mounting for two reasons:\n\t\t// 1. As each node[SUSPENDED_COUNT] starts from 1, this iteration increases\n\t\t//    each node[RELEASED_COUNT] by 1, therefore balancing the counters.\n\t\t//    The nodes can now be completely consumed from the linked list.\n\t\t// 2. Handle nodes that might have gotten resolved between render and\n\t\t//    componentDidMount.\n\t\tthis._map.forEach((node, child) => {\n\t\t\tresolve(this, child, node);\n\t\t});\n\t};\n","import { createElement, render } from 'preact';\n\n/**\n * @param {import('../../src/index').RenderableProps<{ context: any }>} props\n */\nfunction ContextProvider(props) {\n\tthis.getChildContext = () => props.context;\n\treturn props.children;\n}\n\n/**\n * Portal component\n * @this {import('./internal').Component}\n * @param {object | null | undefined} props\n *\n * TODO: use createRoot() instead of fake root\n */\nfunction Portal(props) {\n\tconst _this = this;\n\tlet container = props._container;\n\n\t_this.componentWillUnmount = function () {\n\t\trender(null, _this._temp);\n\t\t_this._temp = null;\n\t\t_this._container = null;\n\t};\n\n\t// When we change container we should clear our old container and\n\t// indicate a new mount.\n\tif (_this._container && _this._container !== container) {\n\t\t_this.componentWillUnmount();\n\t}\n\n\t// When props.vnode is undefined/false/null we are dealing with some kind of\n\t// conditional vnode. This should not trigger a render.\n\tif (props._vnode) {\n\t\tif (!_this._temp) {\n\t\t\t_this._container = container;\n\n\t\t\t// Create a fake DOM parent node that manages a subset of `container`'s children:\n\t\t\t_this._temp = {\n\t\t\t\tnodeType: 1,\n\t\t\t\tparentNode: container,\n\t\t\t\tchildNodes: [],\n\t\t\t\tappendChild(child) {\n\t\t\t\t\tthis.childNodes.push(child);\n\t\t\t\t\t_this._container.appendChild(child);\n\t\t\t\t},\n\t\t\t\tinsertBefore(child, before) {\n\t\t\t\t\tthis.childNodes.push(child);\n\t\t\t\t\t_this._container.appendChild(child);\n\t\t\t\t},\n\t\t\t\tremoveChild(child) {\n\t\t\t\t\tthis.childNodes.splice(this.childNodes.indexOf(child) >>> 1, 1);\n\t\t\t\t\t_this._container.removeChild(child);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t// Render our wrapping element into temp.\n\t\trender(\n\t\t\tcreateElement(ContextProvider, { context: _this.context }, props._vnode),\n\t\t\t_this._temp\n\t\t);\n\t}\n\t// When we come from a conditional render, on a mounted\n\t// portal we should clear the DOM.\n\telse if (_this._temp) {\n\t\t_this.componentWillUnmount();\n\t}\n}\n\n/**\n * Create a `Portal` to continue rendering the vnode tree at a different DOM node\n * @param {import('./internal').VNode} vnode The vnode to render\n * @param {import('./internal').PreactElement} container The DOM node to continue rendering in to.\n */\nexport function createPortal(vnode, container) {\n\tconst el = createElement(Portal, { _vnode: vnode, _container: container });\n\tel.containerInfo = container;\n\treturn el;\n}\n","import {\n\trender as preactRender,\n\thydrate as preactHydrate,\n\toptions,\n\ttoChildArray,\n\tComponent\n} from 'preact';\n\nexport const REACT_ELEMENT_TYPE =\n\t(typeof Symbol != 'undefined' && Symbol.for && Symbol.for('react.element')) ||\n\t0xeac7;\n\nconst CAMEL_PROPS =\n\t/^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;\nconst ON_ANI = /^on(Ani|Tra|Tou|BeforeInp|Compo)/;\nconst CAMEL_REPLACE = /[A-Z0-9]/g;\n\nconst IS_DOM = typeof document !== 'undefined';\n\n// Input types for which onchange should not be converted to oninput.\n// type=\"file|checkbox|radio\", plus \"range\" in IE11.\n// (IE11 doesn't support Symbol, which we use here to turn `rad` into `ra` which matches \"range\")\nconst onChangeInputType = type =>\n\t(typeof Symbol != 'undefined' && typeof Symbol() == 'symbol'\n\t\t? /fil|che|rad/\n\t\t: /fil|che|ra/\n\t).test(type);\n\n// Some libraries like `react-virtualized` explicitly check for this.\nComponent.prototype.isReactComponent = {};\n\n// `UNSAFE_*` lifecycle hooks\n// Preact only ever invokes the unprefixed methods.\n// Here we provide a base \"fallback\" implementation that calls any defined UNSAFE_ prefixed method.\n// - If a component defines its own `componentDidMount()` (including via defineProperty), use that.\n// - If a component defines `UNSAFE_componentDidMount()`, `componentDidMount` is the alias getter/setter.\n// - If anything assigns to an `UNSAFE_*` property, the assignment is forwarded to the unprefixed property.\n// See https://github.com/preactjs/preact/issues/1941\n[\n\t'componentWillMount',\n\t'componentWillReceiveProps',\n\t'componentWillUpdate'\n].forEach(key => {\n\tObject.defineProperty(Component.prototype, key, {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn this['UNSAFE_' + key];\n\t\t},\n\t\tset(v) {\n\t\t\tObject.defineProperty(this, key, {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: v\n\t\t\t});\n\t\t}\n\t});\n});\n\n/**\n * Proxy render() since React returns a Component reference.\n * @param {import('./internal').VNode} vnode VNode tree to render\n * @param {import('./internal').PreactElement} parent DOM node to render vnode tree into\n * @param {() => void} [callback] Optional callback that will be called after rendering\n * @returns {import('./internal').Component | null} The root component reference or null\n */\nexport function render(vnode, parent, callback) {\n\t// React destroys any existing DOM nodes, see #1727\n\t// ...but only on the first render, see #1828\n\tif (parent._children == null) {\n\t\tparent.textContent = '';\n\t}\n\n\tpreactRender(vnode, parent);\n\tif (typeof callback == 'function') callback();\n\n\treturn vnode ? vnode._component : null;\n}\n\nexport function hydrate(vnode, parent, callback) {\n\tpreactHydrate(vnode, parent);\n\tif (typeof callback == 'function') callback();\n\n\treturn vnode ? vnode._component : null;\n}\n\nlet oldEventHook = options.event;\noptions.event = e => {\n\tif (oldEventHook) e = oldEventHook(e);\n\te.persist = empty;\n\te.isPropagationStopped = isPropagationStopped;\n\te.isDefaultPrevented = isDefaultPrevented;\n\treturn (e.nativeEvent = e);\n};\n\nfunction empty() {}\n\nfunction isPropagationStopped() {\n\treturn this.cancelBubble;\n}\n\nfunction isDefaultPrevented() {\n\treturn this.defaultPrevented;\n}\n\nconst classNameDescriptorNonEnumberable = {\n\tenumerable: false,\n\tconfigurable: true,\n\tget() {\n\t\treturn this.class;\n\t}\n};\n\nfunction handleDomVNode(vnode) {\n\tlet props = vnode.props,\n\t\ttype = vnode.type,\n\t\tnormalizedProps = {};\n\n\tfor (let i in props) {\n\t\tlet value = props[i];\n\n\t\tif (\n\t\t\t(i === 'value' && 'defaultValue' in props && value == null) ||\n\t\t\t// Emulate React's behavior of not rendering the contents of noscript tags on the client.\n\t\t\t(IS_DOM && i === 'children' && type === 'noscript') ||\n\t\t\ti === 'class' ||\n\t\t\ti === 'className'\n\t\t) {\n\t\t\t// Skip applying value if it is null/undefined and we already set\n\t\t\t// a default value\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet lowerCased = i.toLowerCase();\n\t\tif (i === 'defaultValue' && 'value' in props && props.value == null) {\n\t\t\t// `defaultValue` is treated as a fallback `value` when a value prop is present but null/undefined.\n\t\t\t// `defaultValue` for Elements with no value prop is the same as the DOM defaultValue property.\n\t\t\ti = 'value';\n\t\t} else if (i === 'download' && value === true) {\n\t\t\t// Calling `setAttribute` with a truthy value will lead to it being\n\t\t\t// passed as a stringified value, e.g. `download=\"true\"`. React\n\t\t\t// converts it to an empty string instead, otherwise the attribute\n\t\t\t// value will be used as the file name and the file will be called\n\t\t\t// \"true\" upon downloading it.\n\t\t\tvalue = '';\n\t\t} else if (lowerCased === 'ondoubleclick') {\n\t\t\ti = 'ondblclick';\n\t\t} else if (\n\t\t\tlowerCased === 'onchange' &&\n\t\t\t(type === 'input' || type === 'textarea') &&\n\t\t\t!onChangeInputType(props.type)\n\t\t) {\n\t\t\tlowerCased = i = 'oninput';\n\t\t} else if (lowerCased === 'onfocus') {\n\t\t\ti = 'onfocusin';\n\t\t} else if (lowerCased === 'onblur') {\n\t\t\ti = 'onfocusout';\n\t\t} else if (ON_ANI.test(i)) {\n\t\t\ti = lowerCased;\n\t\t} else if (type.indexOf('-') === -1 && CAMEL_PROPS.test(i)) {\n\t\t\ti = i.replace(CAMEL_REPLACE, '-$&').toLowerCase();\n\t\t} else if (value === null) {\n\t\t\tvalue = undefined;\n\t\t}\n\n\t\t// Add support for onInput and onChange, see #3561\n\t\t// if we have an oninput prop already change it to oninputCapture\n\t\tif (lowerCased === 'oninput') {\n\t\t\ti = lowerCased;\n\t\t\tif (normalizedProps[i]) {\n\t\t\t\ti = 'oninputCapture';\n\t\t\t}\n\t\t}\n\n\t\tnormalizedProps[i] = value;\n\t}\n\n\t// Add support for array select values: <select multiple value={[]} />\n\tif (\n\t\ttype == 'select' &&\n\t\tnormalizedProps.multiple &&\n\t\tArray.isArray(normalizedProps.value)\n\t) {\n\t\t// forEach() always returns undefined, which we abuse here to unset the value prop.\n\t\tnormalizedProps.value = toChildArray(props.children).forEach(child => {\n\t\t\tchild.props.selected =\n\t\t\t\tnormalizedProps.value.indexOf(child.props.value) != -1;\n\t\t});\n\t}\n\n\t// Adding support for defaultValue in select tag\n\tif (type == 'select' && normalizedProps.defaultValue != null) {\n\t\tnormalizedProps.value = toChildArray(props.children).forEach(child => {\n\t\t\tif (normalizedProps.multiple) {\n\t\t\t\tchild.props.selected =\n\t\t\t\t\tnormalizedProps.defaultValue.indexOf(child.props.value) != -1;\n\t\t\t} else {\n\t\t\t\tchild.props.selected =\n\t\t\t\t\tnormalizedProps.defaultValue == child.props.value;\n\t\t\t}\n\t\t});\n\t}\n\n\tif (props.class && !props.className) {\n\t\tnormalizedProps.class = props.class;\n\t\tObject.defineProperty(\n\t\t\tnormalizedProps,\n\t\t\t'className',\n\t\t\tclassNameDescriptorNonEnumberable\n\t\t);\n\t} else if (props.className && !props.class) {\n\t\tnormalizedProps.class = normalizedProps.className = props.className;\n\t} else if (props.class && props.className) {\n\t\tnormalizedProps.class = normalizedProps.className = props.className;\n\t}\n\n\tvnode.props = normalizedProps;\n}\n\nlet oldVNodeHook = options.vnode;\noptions.vnode = vnode => {\n\t// only normalize props on Element nodes\n\tif (typeof vnode.type === 'string') {\n\t\thandleDomVNode(vnode);\n\t}\n\n\tvnode.$$typeof = REACT_ELEMENT_TYPE;\n\n\tif (oldVNodeHook) oldVNodeHook(vnode);\n};\n\n// Only needed for react-relay\nlet currentComponent;\nconst oldBeforeRender = options._render;\noptions._render = function (vnode) {\n\tif (oldBeforeRender) {\n\t\toldBeforeRender(vnode);\n\t}\n\tcurrentComponent = vnode._component;\n};\n\nconst oldDiffed = options.diffed;\n/** @type {(vnode: import('./internal').VNode)} */\noptions.diffed = function (vnode) {\n\tif (oldDiffed) {\n\t\toldDiffed(vnode);\n\t}\n\n\tconst props = vnode.props;\n\tconst dom = vnode._dom;\n\tif (\n\t\tdom != null &&\n\t\tvnode.type === 'textarea' &&\n\t\t'value' in props &&\n\t\tprops.value !== dom.value\n\t) {\n\t\tdom.value = props.value == null ? '' : props.value;\n\t}\n\n\tcurrentComponent = null;\n};\n\n// This is a very very private internal function for React it\n// is used to sort-of do runtime dependency injection. So far\n// only `react-relay` makes use of it. It uses it to read the\n// context value.\nexport const __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = {\n\tReactCurrentDispatcher: {\n\t\tcurrent: {\n\t\t\treadContext(context) {\n\t\t\t\treturn currentComponent._globalContext[context._id].props.value;\n\t\t\t}\n\t\t}\n\t}\n};\n","import {\n\tcreateElement,\n\trender as preactRender,\n\tcloneElement as preactCloneElement,\n\tcreateRef,\n\tComponent,\n\tcreateContext,\n\tFragment\n} from 'preact';\nimport {\n\tuseState,\n\tuseId,\n\tuseReducer,\n\tuseEffect,\n\tuseLayoutEffect,\n\tuseRef,\n\tuseImperativeHandle,\n\tuseMemo,\n\tuseCallback,\n\tuseContext,\n\tuseDebugValue\n} from 'preact/hooks';\nimport { PureComponent } from './PureComponent';\nimport { memo } from './memo';\nimport { forwardRef } from './forwardRef';\nimport { Children } from './Children';\nimport { Suspense, lazy } from './suspense';\nimport { SuspenseList } from './suspense-list';\nimport { createPortal } from './portals';\nimport { is } from './util';\nimport {\n\thydrate,\n\trender,\n\tREACT_ELEMENT_TYPE,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n} from './render';\n\nconst version = '17.0.2'; // trick libraries to think we are react\n\n/**\n * Legacy version of createElement.\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component constructor\n */\nfunction createFactory(type) {\n\treturn createElement.bind(null, type);\n}\n\n/**\n * Check if the passed element is a valid (p)react node.\n * @param {*} element The element to check\n * @returns {boolean}\n */\nfunction isValidElement(element) {\n\treturn !!element && element.$$typeof === REACT_ELEMENT_TYPE;\n}\n\n/**\n * Wrap `cloneElement` to abort if the passed element is not a valid element and apply\n * all vnode normalizations.\n * @param {import('./internal').VNode} element The vnode to clone\n * @param {object} props Props to add when cloning\n * @param {Array<import('./internal').ComponentChildren>} rest Optional component children\n */\nfunction cloneElement(element) {\n\tif (!isValidElement(element)) return element;\n\treturn preactCloneElement.apply(null, arguments);\n}\n\n/**\n * Remove a component tree from the DOM, including state and event handlers.\n * @param {import('./internal').PreactElement} container\n * @returns {boolean}\n */\nfunction unmountComponentAtNode(container) {\n\tif (container._children) {\n\t\tpreactRender(null, container);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/**\n * Get the matching DOM node for a component\n * @param {import('./internal').Component} component\n * @returns {import('./internal').PreactElement | null}\n */\nfunction findDOMNode(component) {\n\treturn (\n\t\t(component &&\n\t\t\t(component.base || (component.nodeType === 1 && component))) ||\n\t\tnull\n\t);\n}\n\n/**\n * Deprecated way to control batched rendering inside the reconciler, but we\n * already schedule in batches inside our rendering code\n * @template Arg\n * @param {(arg: Arg) => void} callback function that triggers the updated\n * @param {Arg} [arg] Optional argument that can be passed to the callback\n */\n// eslint-disable-next-line camelcase\nconst unstable_batchedUpdates = (callback, arg) => callback(arg);\n\n/**\n * In React, `flushSync` flushes the entire tree and forces a rerender. It's\n * implmented here as a no-op.\n * @template Arg\n * @template Result\n * @param {(arg: Arg) => Result} callback function that runs before the flush\n * @param {Arg} [arg] Optional argument that can be passed to the callback\n * @returns\n */\nconst flushSync = (callback, arg) => callback(arg);\n\n/**\n * Strict Mode is not implemented in Preact, so we provide a stand-in for it\n * that just renders its children without imposing any restrictions.\n */\nconst StrictMode = Fragment;\n\nexport function startTransition(cb) {\n\tcb();\n}\n\nexport function useDeferredValue(val) {\n\treturn val;\n}\n\nexport function useTransition() {\n\treturn [false, startTransition];\n}\n\n// TODO: in theory this should be done after a VNode is diffed as we want to insert\n// styles/... before it attaches\nexport const useInsertionEffect = useLayoutEffect;\n\n/**\n * This is taken from https://github.com/facebook/react/blob/main/packages/use-sync-external-store/src/useSyncExternalStoreShimClient.js#L84\n * on a high level this cuts out the warnings, ... and attempts a smaller implementation\n */\nexport function useSyncExternalStore(subscribe, getSnapshot) {\n\tconst value = getSnapshot();\n\n\tconst [{ _instance }, forceUpdate] = useState({\n\t\t_instance: { _value: value, _getSnapshot: getSnapshot }\n\t});\n\n\tuseLayoutEffect(() => {\n\t\t_instance._value = value;\n\t\t_instance._getSnapshot = getSnapshot;\n\n\t\tif (!is(_instance._value, getSnapshot())) {\n\t\t\tforceUpdate({ _instance });\n\t\t}\n\t}, [subscribe, value, getSnapshot]);\n\n\tuseEffect(() => {\n\t\tif (!is(_instance._value, _instance._getSnapshot())) {\n\t\t\tforceUpdate({ _instance });\n\t\t}\n\n\t\treturn subscribe(() => {\n\t\t\tif (!is(_instance._value, _instance._getSnapshot())) {\n\t\t\t\tforceUpdate({ _instance });\n\t\t\t}\n\t\t});\n\t}, [subscribe]);\n\n\treturn value;\n}\n\nexport * from 'preact/hooks';\nexport {\n\tversion,\n\tChildren,\n\trender,\n\thydrate,\n\tunmountComponentAtNode,\n\tcreatePortal,\n\tcreateElement,\n\tcreateContext,\n\tcreateFactory,\n\tcloneElement,\n\tcreateRef,\n\tFragment,\n\tisValidElement,\n\tfindDOMNode,\n\tComponent,\n\tPureComponent,\n\tmemo,\n\tforwardRef,\n\tflushSync,\n\t// eslint-disable-next-line camelcase\n\tunstable_batchedUpdates,\n\tStrictMode,\n\tSuspense,\n\tSuspenseList,\n\tlazy,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n};\n\n// React copies the named exports to the default one.\nexport default {\n\tuseState,\n\tuseId,\n\tuseReducer,\n\tuseEffect,\n\tuseLayoutEffect,\n\tuseInsertionEffect,\n\tuseTransition,\n\tuseDeferredValue,\n\tuseSyncExternalStore,\n\tstartTransition,\n\tuseRef,\n\tuseImperativeHandle,\n\tuseMemo,\n\tuseCallback,\n\tuseContext,\n\tuseDebugValue,\n\tversion,\n\tChildren,\n\trender,\n\thydrate,\n\tunmountComponentAtNode,\n\tcreatePortal,\n\tcreateElement,\n\tcreateContext,\n\tcreateFactory,\n\tcloneElement,\n\tcreateRef,\n\tFragment,\n\tisValidElement,\n\tfindDOMNode,\n\tComponent,\n\tPureComponent,\n\tmemo,\n\tforwardRef,\n\tflushSync,\n\tunstable_batchedUpdates,\n\tStrictMode,\n\tSuspense,\n\tSuspenseList,\n\tlazy,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n};\n","let e={data:\"\"},t=t=>\"object\"==typeof window?((t?t.querySelector(\"#_goober\"):window._goober)||Object.assign((t||document.head).appendChild(document.createElement(\"style\")),{innerHTML:\" \",id:\"_goober\"})).firstChild:t||e,r=e=>{let r=t(e),l=r.data;return r.data=\"\",l},l=/(?:([\\u0080-\\uFFFF\\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\\s*)/g,a=/\\/\\*[^]*?\\*\\/|  +/g,n=/\\n+/g,o=(e,t)=>{let r=\"\",l=\"\",a=\"\";for(let n in e){let c=e[n];\"@\"==n[0]?\"i\"==n[1]?r=n+\" \"+c+\";\":l+=\"f\"==n[1]?o(c,n):n+\"{\"+o(c,\"k\"==n[1]?\"\":t)+\"}\":\"object\"==typeof c?l+=o(c,t?t.replace(/([^,])+/g,e=>n.replace(/(^:.*)|([^,])+/g,t=>/&/.test(t)?t.replace(/&/g,e):e?e+\" \"+t:t)):n):null!=c&&(n=/^--/.test(n)?n:n.replace(/[A-Z]/g,\"-$&\").toLowerCase(),a+=o.p?o.p(n,c):n+\":\"+c+\";\")}return r+(t&&a?t+\"{\"+a+\"}\":a)+l},c={},s=e=>{if(\"object\"==typeof e){let t=\"\";for(let r in e)t+=r+s(e[r]);return t}return e},i=(e,t,r,i,p)=>{let u=s(e),d=c[u]||(c[u]=(e=>{let t=0,r=11;for(;t<e.length;)r=101*r+e.charCodeAt(t++)>>>0;return\"go\"+r})(u));if(!c[d]){let t=u!==e?e:(e=>{let t,r,o=[{}];for(;t=l.exec(e.replace(a,\"\"));)t[4]?o.shift():t[3]?(r=t[3].replace(n,\" \").trim(),o.unshift(o[0][r]=o[0][r]||{})):o[0][t[1]]=t[2].replace(n,\" \").trim();return o[0]})(e);c[d]=o(p?{[\"@keyframes \"+d]:t}:t,r?\"\":\".\"+d)}let f=r&&c.g?c.g:null;return r&&(c.g=c[d]),((e,t,r,l)=>{l?t.data=t.data.replace(l,e):-1===t.data.indexOf(e)&&(t.data=r?e+t.data:t.data+e)})(c[d],t,i,f),d},p=(e,t,r)=>e.reduce((e,l,a)=>{let n=t[a];if(n&&n.call){let e=n(r),t=e&&e.props&&e.props.className||/^go/.test(e)&&e;n=t?\".\"+t:e&&\"object\"==typeof e?e.props?\"\":o(e,\"\"):!1===e?\"\":e}return e+l+(null==n?\"\":n)},\"\");function u(e){let r=this||{},l=e.call?e(r.p):e;return i(l.unshift?l.raw?p(l,[].slice.call(arguments,1),r.p):l.reduce((e,t)=>Object.assign(e,t&&t.call?t(r.p):t),{}):l,t(r.target),r.g,r.o,r.k)}let d,f,g,b=u.bind({g:1}),h=u.bind({k:1});function m(e,t,r,l){o.p=t,d=e,f=r,g=l}function j(e,t){let r=this||{};return function(){let l=arguments;function a(n,o){let c=Object.assign({},n),s=c.className||a.className;r.p=Object.assign({theme:f&&f()},c),r.o=/ *go\\d+/.test(s),c.className=u.apply(r,l)+(s?\" \"+s:\"\"),t&&(c.ref=o);let i=e;return e[0]&&(i=c.as||e,delete c.as),g&&i[0]&&g(c),d(i,c)}return t?t(a):a}}export{u as css,r as extractCss,b as glob,h as keyframes,m as setup,j as styled};\n","import { CSSProperties } from 'react';\n\nexport type ToastType = 'success' | 'error' | 'loading' | 'blank' | 'custom';\nexport type ToastPosition =\n  | 'top-left'\n  | 'top-center'\n  | 'top-right'\n  | 'bottom-left'\n  | 'bottom-center'\n  | 'bottom-right';\n\nexport type Renderable = JSX.Element | string | null;\n\nexport interface IconTheme {\n  primary: string;\n  secondary: string;\n}\n\nexport type ValueFunction<TValue, TArg> = (arg: TArg) => TValue;\nexport type ValueOrFunction<TValue, TArg> =\n  | TValue\n  | ValueFunction<TValue, TArg>;\n\nconst isFunction = <TValue, TArg>(\n  valOrFunction: ValueOrFunction<TValue, TArg>\n): valOrFunction is ValueFunction<TValue, TArg> =>\n  typeof valOrFunction === 'function';\n\nexport const resolveValue = <TValue, TArg>(\n  valOrFunction: ValueOrFunction<TValue, TArg>,\n  arg: TArg\n): TValue => (isFunction(valOrFunction) ? valOrFunction(arg) : valOrFunction);\n\nexport interface Toast {\n  type: ToastType;\n  id: string;\n  message: ValueOrFunction<Renderable, Toast>;\n  icon?: Renderable;\n  duration?: number;\n  pauseDuration: number;\n  position?: ToastPosition;\n\n  ariaProps: {\n    role: 'status' | 'alert';\n    'aria-live': 'assertive' | 'off' | 'polite';\n  };\n\n  style?: CSSProperties;\n  className?: string;\n  iconTheme?: IconTheme;\n\n  createdAt: number;\n  visible: boolean;\n  height?: number;\n}\n\nexport type ToastOptions = Partial<\n  Pick<\n    Toast,\n    | 'id'\n    | 'icon'\n    | 'duration'\n    | 'ariaProps'\n    | 'className'\n    | 'style'\n    | 'position'\n    | 'iconTheme'\n  >\n>;\n\nexport type DefaultToastOptions = ToastOptions & {\n  [key in ToastType]?: ToastOptions;\n};\n\nexport interface ToasterProps {\n  position?: ToastPosition;\n  toastOptions?: DefaultToastOptions;\n  reverseOrder?: boolean;\n  gutter?: number;\n  containerStyle?: React.CSSProperties;\n  containerClassName?: string;\n  children?: (toast: Toast) => JSX.Element;\n}\n\nexport interface ToastWrapperProps {\n  id: string;\n  className?: string;\n  style?: React.CSSProperties;\n  onHeightUpdate: (id: string, height: number) => void;\n  children?: React.ReactNode;\n}\n","export const genId = (() => {\n  let count = 0;\n  return () => {\n    return (++count).toString();\n  };\n})();\n\nexport const prefersReducedMotion = (() => {\n  // Cache result\n  let shouldReduceMotion: boolean | undefined = undefined;\n\n  return () => {\n    if (shouldReduceMotion === undefined && typeof window !== 'undefined') {\n      const mediaQuery = matchMedia('(prefers-reduced-motion: reduce)');\n      shouldReduceMotion = !mediaQuery || mediaQuery.matches;\n    }\n    return shouldReduceMotion;\n  };\n})();\n","import { useEffect, useState } from 'react';\nimport { DefaultToastOptions, Toast, ToastType } from './types';\n\nconst TOAST_LIMIT = 20;\n\nexport enum ActionType {\n  ADD_TOAST,\n  UPDATE_TOAST,\n  UPSERT_TOAST,\n  DISMISS_TOAST,\n  REMOVE_TOAST,\n  START_PAUSE,\n  END_PAUSE,\n}\n\ntype Action =\n  | {\n      type: ActionType.ADD_TOAST;\n      toast: Toast;\n    }\n  | {\n      type: ActionType.UPSERT_TOAST;\n      toast: Toast;\n    }\n  | {\n      type: ActionType.UPDATE_TOAST;\n      toast: Partial<Toast>;\n    }\n  | {\n      type: ActionType.DISMISS_TOAST;\n      toastId?: string;\n    }\n  | {\n      type: ActionType.REMOVE_TOAST;\n      toastId?: string;\n    }\n  | {\n      type: ActionType.START_PAUSE;\n      time: number;\n    }\n  | {\n      type: ActionType.END_PAUSE;\n      time: number;\n    };\n\ninterface State {\n  toasts: Toast[];\n  pausedAt: number | undefined;\n}\n\nconst toastTimeouts = new Map<Toast['id'], ReturnType<typeof setTimeout>>();\n\nexport const TOAST_EXPIRE_DISMISS_DELAY = 1000;\n\nconst addToRemoveQueue = (toastId: string) => {\n  if (toastTimeouts.has(toastId)) {\n    return;\n  }\n\n  const timeout = setTimeout(() => {\n    toastTimeouts.delete(toastId);\n    dispatch({\n      type: ActionType.REMOVE_TOAST,\n      toastId: toastId,\n    });\n  }, TOAST_EXPIRE_DISMISS_DELAY);\n\n  toastTimeouts.set(toastId, timeout);\n};\n\nconst clearFromRemoveQueue = (toastId: string) => {\n  const timeout = toastTimeouts.get(toastId);\n  if (timeout) {\n    clearTimeout(timeout);\n  }\n};\n\nexport const reducer = (state: State, action: Action): State => {\n  switch (action.type) {\n    case ActionType.ADD_TOAST:\n      return {\n        ...state,\n        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),\n      };\n\n    case ActionType.UPDATE_TOAST:\n      //  ! Side effects !\n      if (action.toast.id) {\n        clearFromRemoveQueue(action.toast.id);\n      }\n\n      return {\n        ...state,\n        toasts: state.toasts.map((t) =>\n          t.id === action.toast.id ? { ...t, ...action.toast } : t\n        ),\n      };\n\n    case ActionType.UPSERT_TOAST:\n      const { toast } = action;\n      return state.toasts.find((t) => t.id === toast.id)\n        ? reducer(state, { type: ActionType.UPDATE_TOAST, toast })\n        : reducer(state, { type: ActionType.ADD_TOAST, toast });\n\n    case ActionType.DISMISS_TOAST:\n      const { toastId } = action;\n\n      // ! Side effects ! - This could be execrated into a dismissToast() action, but I'll keep it here for simplicity\n      if (toastId) {\n        addToRemoveQueue(toastId);\n      } else {\n        state.toasts.forEach((toast) => {\n          addToRemoveQueue(toast.id);\n        });\n      }\n\n      return {\n        ...state,\n        toasts: state.toasts.map((t) =>\n          t.id === toastId || toastId === undefined\n            ? {\n                ...t,\n                visible: false,\n              }\n            : t\n        ),\n      };\n    case ActionType.REMOVE_TOAST:\n      if (action.toastId === undefined) {\n        return {\n          ...state,\n          toasts: [],\n        };\n      }\n      return {\n        ...state,\n        toasts: state.toasts.filter((t) => t.id !== action.toastId),\n      };\n\n    case ActionType.START_PAUSE:\n      return {\n        ...state,\n        pausedAt: action.time,\n      };\n\n    case ActionType.END_PAUSE:\n      const diff = action.time - (state.pausedAt || 0);\n\n      return {\n        ...state,\n        pausedAt: undefined,\n        toasts: state.toasts.map((t) => ({\n          ...t,\n          pauseDuration: t.pauseDuration + diff,\n        })),\n      };\n  }\n};\n\nconst listeners: Array<(state: State) => void> = [];\n\nlet memoryState: State = { toasts: [], pausedAt: undefined };\n\nexport const dispatch = (action: Action) => {\n  memoryState = reducer(memoryState, action);\n  listeners.forEach((listener) => {\n    listener(memoryState);\n  });\n};\n\nexport const defaultTimeouts: {\n  [key in ToastType]: number;\n} = {\n  blank: 4000,\n  error: 4000,\n  success: 2000,\n  loading: Infinity,\n  custom: 4000,\n};\n\nexport const useStore = (toastOptions: DefaultToastOptions = {}): State => {\n  const [state, setState] = useState<State>(memoryState);\n  useEffect(() => {\n    listeners.push(setState);\n    return () => {\n      const index = listeners.indexOf(setState);\n      if (index > -1) {\n        listeners.splice(index, 1);\n      }\n    };\n  }, [state]);\n\n  const mergedToasts = state.toasts.map((t) => ({\n    ...toastOptions,\n    ...toastOptions[t.type],\n    ...t,\n    duration:\n      t.duration ||\n      toastOptions[t.type]?.duration ||\n      toastOptions?.duration ||\n      defaultTimeouts[t.type],\n    style: {\n      ...toastOptions.style,\n      ...toastOptions[t.type]?.style,\n      ...t.style,\n    },\n  }));\n\n  return {\n    ...state,\n    toasts: mergedToasts,\n  };\n};\n","import {\n  Renderable,\n  Toast,\n  ToastOptions,\n  ToastType,\n  DefaultToastOptions,\n  ValueOrFunction,\n  resolveValue,\n} from './types';\nimport { genId } from './utils';\nimport { dispatch, ActionType } from './store';\n\ntype Message = ValueOrFunction<Renderable, Toast>;\n\ntype ToastHandler = (message: Message, options?: ToastOptions) => string;\n\nconst createToast = (\n  message: Message,\n  type: ToastType = 'blank',\n  opts?: ToastOptions\n): Toast => ({\n  createdAt: Date.now(),\n  visible: true,\n  type,\n  ariaProps: {\n    role: 'status',\n    'aria-live': 'polite',\n  },\n  message,\n  pauseDuration: 0,\n  ...opts,\n  id: opts?.id || genId(),\n});\n\nconst createHandler =\n  (type?: ToastType): ToastHandler =>\n  (message, options) => {\n    const toast = createToast(message, type, options);\n    dispatch({ type: ActionType.UPSERT_TOAST, toast });\n    return toast.id;\n  };\n\nconst toast = (message: Message, opts?: ToastOptions) =>\n  createHandler('blank')(message, opts);\n\ntoast.error = createHandler('error');\ntoast.success = createHandler('success');\ntoast.loading = createHandler('loading');\ntoast.custom = createHandler('custom');\n\ntoast.dismiss = (toastId?: string) => {\n  dispatch({\n    type: ActionType.DISMISS_TOAST,\n    toastId,\n  });\n};\n\ntoast.remove = (toastId?: string) =>\n  dispatch({ type: ActionType.REMOVE_TOAST, toastId });\n\ntoast.promise = <T>(\n  promise: Promise<T>,\n  msgs: {\n    loading: Renderable;\n    success: ValueOrFunction<Renderable, T>;\n    error: ValueOrFunction<Renderable, any>;\n  },\n  opts?: DefaultToastOptions\n) => {\n  const id = toast.loading(msgs.loading, { ...opts, ...opts?.loading });\n\n  promise\n    .then((p) => {\n      toast.success(resolveValue(msgs.success, p), {\n        id,\n        ...opts,\n        ...opts?.success,\n      });\n      return p;\n    })\n    .catch((e) => {\n      toast.error(resolveValue(msgs.error, e), {\n        id,\n        ...opts,\n        ...opts?.error,\n      });\n    });\n\n  return promise;\n};\n\nexport { toast };\n","import { useEffect, useCallback } from 'react';\nimport { dispatch, ActionType, useStore } from './store';\nimport { toast } from './toast';\nimport { DefaultToastOptions, Toast, ToastPosition } from './types';\n\nconst updateHeight = (toastId: string, height: number) => {\n  dispatch({\n    type: ActionType.UPDATE_TOAST,\n    toast: { id: toastId, height },\n  });\n};\nconst startPause = () => {\n  dispatch({\n    type: ActionType.START_PAUSE,\n    time: Date.now(),\n  });\n};\n\nexport const useToaster = (toastOptions?: DefaultToastOptions) => {\n  const { toasts, pausedAt } = useStore(toastOptions);\n\n  useEffect(() => {\n    if (pausedAt) {\n      return;\n    }\n\n    const now = Date.now();\n    const timeouts = toasts.map((t) => {\n      if (t.duration === Infinity) {\n        return;\n      }\n\n      const durationLeft =\n        (t.duration || 0) + t.pauseDuration - (now - t.createdAt);\n\n      if (durationLeft < 0) {\n        if (t.visible) {\n          toast.dismiss(t.id);\n        }\n        return;\n      }\n      return setTimeout(() => toast.dismiss(t.id), durationLeft);\n    });\n\n    return () => {\n      timeouts.forEach((timeout) => timeout && clearTimeout(timeout));\n    };\n  }, [toasts, pausedAt]);\n\n  const endPause = useCallback(() => {\n    if (pausedAt) {\n      dispatch({ type: ActionType.END_PAUSE, time: Date.now() });\n    }\n  }, [pausedAt]);\n\n  const calculateOffset = useCallback(\n    (\n      toast: Toast,\n      opts?: {\n        reverseOrder?: boolean;\n        gutter?: number;\n        defaultPosition?: ToastPosition;\n      }\n    ) => {\n      const { reverseOrder = false, gutter = 8, defaultPosition } = opts || {};\n\n      const relevantToasts = toasts.filter(\n        (t) =>\n          (t.position || defaultPosition) ===\n            (toast.position || defaultPosition) && t.height\n      );\n      const toastIndex = relevantToasts.findIndex((t) => t.id === toast.id);\n      const toastsBefore = relevantToasts.filter(\n        (toast, i) => i < toastIndex && toast.visible\n      ).length;\n\n      const offset = relevantToasts\n        .filter((t) => t.visible)\n        .slice(...(reverseOrder ? [toastsBefore + 1] : [0, toastsBefore]))\n        .reduce((acc, t) => acc + (t.height || 0) + gutter, 0);\n\n      return offset;\n    },\n    [toasts]\n  );\n\n  return {\n    toasts,\n    handlers: {\n      updateHeight,\n      startPause,\n      endPause,\n      calculateOffset,\n    },\n  };\n};\n","import * as React from 'react';\nimport { styled, keyframes } from 'goober';\n\nimport { Toast, ToastPosition, resolveValue, Renderable } from '../core/types';\nimport { ToastIcon } from './toast-icon';\nimport { prefersReducedMotion } from '../core/utils';\n\nconst enterAnimation = (factor: number) => `\n0% {transform: translate3d(0,${factor * -200}%,0) scale(.6); opacity:.5;}\n100% {transform: translate3d(0,0,0) scale(1); opacity:1;}\n`;\n\nconst exitAnimation = (factor: number) => `\n0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}\n100% {transform: translate3d(0,${factor * -150}%,-1px) scale(.6); opacity:0;}\n`;\n\nconst fadeInAnimation = `0%{opacity:0;} 100%{opacity:1;}`;\nconst fadeOutAnimation = `0%{opacity:1;} 100%{opacity:0;}`;\n\nconst ToastBarBase = styled('div')`\n  display: flex;\n  align-items: center;\n  background: #fff;\n  color: #363636;\n  line-height: 1.3;\n  will-change: transform;\n  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);\n  max-width: 350px;\n  pointer-events: auto;\n  padding: 8px 10px;\n  border-radius: 8px;\n`;\n\nconst Message = styled('div')`\n  display: flex;\n  justify-content: center;\n  margin: 4px 10px;\n  color: inherit;\n  flex: 1 1 auto;\n  white-space: pre-line;\n`;\n\ninterface ToastBarProps {\n  toast: Toast;\n  position?: ToastPosition;\n  style?: React.CSSProperties;\n  children?: (components: {\n    icon: Renderable;\n    message: Renderable;\n  }) => Renderable;\n}\n\nconst getAnimationStyle = (\n  position: ToastPosition,\n  visible: boolean\n): React.CSSProperties => {\n  const top = position.includes('top');\n  const factor = top ? 1 : -1;\n\n  const [enter, exit] = prefersReducedMotion()\n    ? [fadeInAnimation, fadeOutAnimation]\n    : [enterAnimation(factor), exitAnimation(factor)];\n\n  return {\n    animation: visible\n      ? `${keyframes(enter)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards`\n      : `${keyframes(exit)} 0.4s forwards cubic-bezier(.06,.71,.55,1)`,\n  };\n};\n\nexport const ToastBar: React.FC<ToastBarProps> = React.memo(\n  ({ toast, position, style, children }) => {\n    const animationStyle: React.CSSProperties = toast.height\n      ? getAnimationStyle(\n          toast.position || position || 'top-center',\n          toast.visible\n        )\n      : { opacity: 0 };\n\n    const icon = <ToastIcon toast={toast} />;\n    const message = (\n      <Message {...toast.ariaProps}>\n        {resolveValue(toast.message, toast)}\n      </Message>\n    );\n\n    return (\n      <ToastBarBase\n        className={toast.className}\n        style={{\n          ...animationStyle,\n          ...style,\n          ...toast.style,\n        }}\n      >\n        {typeof children === 'function' ? (\n          children({\n            icon,\n            message,\n          })\n        ) : (\n          <>\n            {icon}\n            {message}\n          </>\n        )}\n      </ToastBarBase>\n    );\n  }\n);\n","import * as React from 'react';\nimport { styled, keyframes } from 'goober';\n\nimport { Toast } from '../core/types';\nimport { ErrorIcon, ErrorTheme } from './error';\nimport { LoaderIcon, LoaderTheme } from './loader';\nimport { CheckmarkIcon, CheckmarkTheme } from './checkmark';\n\nconst StatusWrapper = styled('div')`\n  position: absolute;\n`;\n\nconst IndicatorWrapper = styled('div')`\n  position: relative;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  min-width: 20px;\n  min-height: 20px;\n`;\n\nconst enter = keyframes`\nfrom {\n  transform: scale(0.6);\n  opacity: 0.4;\n}\nto {\n  transform: scale(1);\n  opacity: 1;\n}`;\n\nexport const AnimatedIconWrapper = styled('div')`\n  position: relative;\n  transform: scale(0.6);\n  opacity: 0.4;\n  min-width: 20px;\n  animation: ${enter} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)\n    forwards;\n`;\n\nexport type IconThemes = Partial<{\n  success: CheckmarkTheme;\n  error: ErrorTheme;\n  loading: LoaderTheme;\n}>;\n\nexport const ToastIcon: React.FC<{\n  toast: Toast;\n}> = ({ toast }) => {\n  const { icon, type, iconTheme } = toast;\n  if (icon !== undefined) {\n    if (typeof icon === 'string') {\n      return <AnimatedIconWrapper>{icon}</AnimatedIconWrapper>;\n    } else {\n      return icon;\n    }\n  }\n\n  if (type === 'blank') {\n    return null;\n  }\n\n  return (\n    <IndicatorWrapper>\n      <LoaderIcon {...iconTheme} />\n      {type !== 'loading' && (\n        <StatusWrapper>\n          {type === 'error' ? (\n            <ErrorIcon {...iconTheme} />\n          ) : (\n            <CheckmarkIcon {...iconTheme} />\n          )}\n        </StatusWrapper>\n      )}\n    </IndicatorWrapper>\n  );\n};\n","import { styled, keyframes } from 'goober';\n\nconst circleAnimation = keyframes`\nfrom {\n  transform: scale(0) rotate(45deg);\n\topacity: 0;\n}\nto {\n transform: scale(1) rotate(45deg);\n  opacity: 1;\n}`;\n\nconst firstLineAnimation = keyframes`\nfrom {\n  transform: scale(0);\n  opacity: 0;\n}\nto {\n  transform: scale(1);\n  opacity: 1;\n}`;\n\nconst secondLineAnimation = keyframes`\nfrom {\n  transform: scale(0) rotate(90deg);\n\topacity: 0;\n}\nto {\n  transform: scale(1) rotate(90deg);\n\topacity: 1;\n}`;\n\nexport interface ErrorTheme {\n  primary?: string;\n  secondary?: string;\n}\n\nexport const ErrorIcon = styled('div')<ErrorTheme>`\n  width: 20px;\n  opacity: 0;\n  height: 20px;\n  border-radius: 10px;\n  background: ${(p) => p.primary || '#ff4b4b'};\n  position: relative;\n  transform: rotate(45deg);\n\n  animation: ${circleAnimation} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)\n    forwards;\n  animation-delay: 100ms;\n\n  &:after,\n  &:before {\n    content: '';\n    animation: ${firstLineAnimation} 0.15s ease-out forwards;\n    animation-delay: 150ms;\n    position: absolute;\n    border-radius: 3px;\n    opacity: 0;\n    background: ${(p) => p.secondary || '#fff'};\n    bottom: 9px;\n    left: 4px;\n    height: 2px;\n    width: 12px;\n  }\n\n  &:before {\n    animation: ${secondLineAnimation} 0.15s ease-out forwards;\n    animation-delay: 180ms;\n    transform: rotate(90deg);\n  }\n`;\n","import { styled, keyframes } from 'goober';\n\nconst rotate = keyframes`\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n`;\n\nexport interface LoaderTheme {\n  primary?: string;\n  secondary?: string;\n}\n\nexport const LoaderIcon = styled('div')<LoaderTheme>`\n  width: 12px;\n  height: 12px;\n  box-sizing: border-box;\n  border: 2px solid;\n  border-radius: 100%;\n  border-color: ${(p) => p.secondary || '#e0e0e0'};\n  border-right-color: ${(p) => p.primary || '#616161'};\n  animation: ${rotate} 1s linear infinite;\n`;\n","import { styled, keyframes } from 'goober';\n\nconst circleAnimation = keyframes`\nfrom {\n  transform: scale(0) rotate(45deg);\n\topacity: 0;\n}\nto {\n  transform: scale(1) rotate(45deg);\n\topacity: 1;\n}`;\n\nconst checkmarkAnimation = keyframes`\n0% {\n\theight: 0;\n\twidth: 0;\n\topacity: 0;\n}\n40% {\n  height: 0;\n\twidth: 6px;\n\topacity: 1;\n}\n100% {\n  opacity: 1;\n  height: 10px;\n}`;\n\nexport interface CheckmarkTheme {\n  primary?: string;\n  secondary?: string;\n}\n\nexport const CheckmarkIcon = styled('div')<CheckmarkTheme>`\n  width: 20px;\n  opacity: 0;\n  height: 20px;\n  border-radius: 10px;\n  background: ${(p) => p.primary || '#61d345'};\n  position: relative;\n  transform: rotate(45deg);\n\n  animation: ${circleAnimation} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)\n    forwards;\n  animation-delay: 100ms;\n  &:after {\n    content: '';\n    box-sizing: border-box;\n    animation: ${checkmarkAnimation} 0.2s ease-out forwards;\n    opacity: 0;\n    animation-delay: 200ms;\n    position: absolute;\n    border-right: 2px solid;\n    border-bottom: 2px solid;\n    border-color: ${(p) => p.secondary || '#fff'};\n    bottom: 6px;\n    left: 6px;\n    height: 10px;\n    width: 6px;\n  }\n`;\n","import { css, setup } from 'goober';\nimport * as React from 'react';\nimport {\n  resolveValue,\n  ToasterProps,\n  ToastPosition,\n  ToastWrapperProps,\n} from '../core/types';\nimport { useToaster } from '../core/use-toaster';\nimport { prefersReducedMotion } from '../core/utils';\nimport { ToastBar } from './toast-bar';\n\nsetup(React.createElement);\n\nconst ToastWrapper = ({\n  id,\n  className,\n  style,\n  onHeightUpdate,\n  children,\n}: ToastWrapperProps) => {\n  const ref = React.useCallback(\n    (el: HTMLElement | null) => {\n      if (el) {\n        const updateHeight = () => {\n          const height = el.getBoundingClientRect().height;\n          onHeightUpdate(id, height);\n        };\n        updateHeight();\n        new MutationObserver(updateHeight).observe(el, {\n          subtree: true,\n          childList: true,\n          characterData: true,\n        });\n      }\n    },\n    [id, onHeightUpdate]\n  );\n\n  return (\n    <div ref={ref} className={className} style={style}>\n      {children}\n    </div>\n  );\n};\n\nconst getPositionStyle = (\n  position: ToastPosition,\n  offset: number\n): React.CSSProperties => {\n  const top = position.includes('top');\n  const verticalStyle: React.CSSProperties = top ? { top: 0 } : { bottom: 0 };\n  const horizontalStyle: React.CSSProperties = position.includes('center')\n    ? {\n        justifyContent: 'center',\n      }\n    : position.includes('right')\n    ? {\n        justifyContent: 'flex-end',\n      }\n    : {};\n  return {\n    left: 0,\n    right: 0,\n    display: 'flex',\n    position: 'absolute',\n    transition: prefersReducedMotion()\n      ? undefined\n      : `all 230ms cubic-bezier(.21,1.02,.73,1)`,\n    transform: `translateY(${offset * (top ? 1 : -1)}px)`,\n    ...verticalStyle,\n    ...horizontalStyle,\n  };\n};\n\nconst activeClass = css`\n  z-index: 9999;\n  > * {\n    pointer-events: auto;\n  }\n`;\n\nconst DEFAULT_OFFSET = 16;\n\nexport const Toaster: React.FC<ToasterProps> = ({\n  reverseOrder,\n  position = 'top-center',\n  toastOptions,\n  gutter,\n  children,\n  containerStyle,\n  containerClassName,\n}) => {\n  const { toasts, handlers } = useToaster(toastOptions);\n\n  return (\n    <div\n      style={{\n        position: 'fixed',\n        zIndex: 9999,\n        top: DEFAULT_OFFSET,\n        left: DEFAULT_OFFSET,\n        right: DEFAULT_OFFSET,\n        bottom: DEFAULT_OFFSET,\n        pointerEvents: 'none',\n        ...containerStyle,\n      }}\n      className={containerClassName}\n      onMouseEnter={handlers.startPause}\n      onMouseLeave={handlers.endPause}\n    >\n      {toasts.map((t) => {\n        const toastPosition = t.position || position;\n        const offset = handlers.calculateOffset(t, {\n          reverseOrder,\n          gutter,\n          defaultPosition: position,\n        });\n        const positionStyle = getPositionStyle(toastPosition, offset);\n\n        return (\n          <ToastWrapper\n            id={t.id}\n            key={t.id}\n            onHeightUpdate={handlers.updateHeight}\n            className={t.visible ? activeClass : ''}\n            style={positionStyle}\n          >\n            {t.type === 'custom' ? (\n              resolveValue(t.message, t)\n            ) : children ? (\n              children(t)\n            ) : (\n              <ToastBar toast={t} position={toastPosition} />\n            )}\n          </ToastWrapper>\n        );\n      })}\n    </div>\n  );\n};\n","import { toast } from './core/toast';\n\nexport * from './headless';\n\nexport { ToastBar } from './components/toast-bar';\nexport { ToastIcon } from './components/toast-icon';\nexport { Toaster } from './components/toaster';\nexport { CheckmarkIcon } from './components/checkmark';\nexport { ErrorIcon } from './components/error';\nexport { LoaderIcon } from './components/loader';\n\nexport { toast };\nexport default toast;\n","import { render, h } from \"preact\";\nimport { toast, Toaster, ToasterProps } from \"react-hot-toast\";\n\ntype ExtendedToast = typeof toast & {\n  setConfig: (config: Partial<ToasterProps>) => void;\n};\n\ndeclare global {\n  interface Window {\n    toast: ExtendedToast;\n  }\n}\n\nlet root: HTMLElement | null = null;\n\nconst startToaster = (config?: ToasterProps) => {\n  if (!root) {\n    root = document.createElement(\"div\");\n    root.id = \"hot-toast\";\n    document.body.appendChild(root);\n  }\n\n  window.toast = toast as ExtendedToast;\n  window.toast.setConfig = (config: Partial<ToasterProps>) => {\n    startToaster(config);\n  };\n\n  window.toast.setConfig({\n    toastOptions: {\n      duration: 10000,\n    },\n  });\n\n  render(<Toaster {...config} />, root);\n};\n\nstartToaster();\n\nexport { toast, startToaster };\n"],"mappings":"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","names":["slice","options","vnodeId","isValidElement","rerenderQueue","prevDebounce","defer","depthSort","i","EMPTY_OBJ","EMPTY_ARR","IS_NON_DIMENSIONAL","assign","obj","props","removeNode","node","parentNode","removeChild","createElement","type","children","key","ref","normalizedProps","arguments","length","call","defaultProps","createVNode","original","vnode","__k","__","__b","__e","__d","__c","__h","constructor","__v","Fragment","props","children","Component","context","this","getDomSibling","vnode","childIndex","__","indexOf","sibling","__k","length","__e","type","updateParentDomPointers","i","child","__c","base","enqueueRender","c","__d","rerenderQueue","push","process","__r","prevDebounce","options","debounceRendering","defer","renderQueueLength","component","commitQueue","oldVNode","oldDom","parentDom","sort","depthSort","shift","__v","__P","assign","diff","__n","ownerSVGElement","__h","commitRoot","diffChildren","renderResult","newParentVNode","oldParentVNode","globalContext","isSvg","excessDomChildren","isHydrating","j","childVNode","newDom","firstChildDom","refs","oldChildren","EMPTY_ARR","oldChildrenLength","createVNode","Array","isArray","__b","key","ref","EMPTY_OBJ","reorderChildren","placeChild","parentNode","getLastDom","nextSibling","unmount","applyRef","tmp","toChildArray","out","some","nextDom","sibDom","outer","appendChild","insertBefore","lastDom","diffProps","dom","newProps","oldProps","hydrate","setProperty","setStyle","style","value","IS_NON_DIMENSIONAL","test","name","oldValue","useCapture","o","cssText","replace","toLowerCase","slice","l","addEventListener","eventProxyCapture","eventProxy","removeEventListener","removeAttribute","setAttribute","e","event","newVNode","isNew","oldState","snapshot","clearProcessingException","provider","componentContext","renderHook","count","newType","constructor","contextType","__E","prototype","render","doRender","sub","state","_sb","__s","getDerivedStateFromProps","componentWillMount","componentDidMount","componentWillReceiveProps","shouldComponentUpdate","forEach","componentWillUpdate","componentDidUpdate","getChildContext","getSnapshotBeforeUpdate","diffElementNodes","diffed","root","cb","call","oldHtml","newHtml","nodeType","localName","document","createTextNode","createElementNS","createElement","is","data","childNodes","dangerouslySetInnerHTML","attributes","__html","innerHTML","removeNode","checked","current","parentVNode","skipRemove","r","componentWillUnmount","replaceNode","firstChild","slice","EMPTY_ARR","options","__e","error","vnode","oldVNode","errorInfo","component","ctor","handled","__","__c","constructor","getDerivedStateFromError","setState","__d","componentDidCatch","__E","e","vnodeId","isValidElement","Component","prototype","update","callback","s","this","__s","state","assign","props","__v","_sb","push","enqueueRender","forceUpdate","render","Fragment","rerenderQueue","defer","Promise","then","bind","resolve","setTimeout","depthSort","a","b","__b","process","__r","i","currentIndex","currentComponent","previousComponent","prevRaf","currentHook","afterPaintEffects","EMPTY","oldBeforeDiff","options","__b","oldBeforeRender","__r","oldAfterDiff","diffed","oldCommit","__c","oldBeforeUnmount","unmount","getHookState","index","type","__h","hooks","__H","__","length","push","__V","useState","initialState","useReducer","invokeOrReturn","reducer","init","hookState","_reducer","action","currentValue","__N","nextValue","setState","_hasScuFromHooks","updateHookState","p","s","c","stateHooks","filter","x","every","prevScu","call","this","shouldUpdate","forEach","hookItem","props","shouldComponentUpdate","prevCWU","componentWillUpdate","__e","tmp","useEffect","callback","args","state","__s","argsChanged","_pendingArgs","useMemo","factory","args","state","getHookState","currentIndex","argsChanged","_pendingArgs","__h","__V","__","useCallback","callback","currentHook","flushAfterPaintEffects","component","afterPaintEffects","shift","__P","__H","forEach","invokeCleanup","__h","invokeEffect","e","options","__e","__v","__b","vnode","currentComponent","oldBeforeDiff","__r","oldBeforeRender","currentIndex","hooks","__c","previousComponent","__","hookItem","__N","EMPTY","_pendingArgs","diffed","oldAfterDiff","c","length","push","prevRaf","requestAnimationFrame","afterNextFrame","__V","commitQueue","some","filter","cb","oldCommit","unmount","oldBeforeUnmount","hasErrored","s","HAS_RAF","callback","raf","done","clearTimeout","timeout","cancelAnimationFrame","setTimeout","hook","comp","cleanup","argsChanged","oldArgs","newArgs","arg","index","invokeOrReturn","f","assign","obj","props","i","shallowDiffers","a","b","PureComponent","p","this","props","memo","c","comparer","shouldUpdate","nextProps","ref","updateRef","call","current","shallowDiffers","Memoed","shouldComponentUpdate","createElement","displayName","name","prototype","isReactComponent","Component","isPureReactComponent","state","oldDiffHook","options","__b","vnode","type","__f","REACT_FORWARD_SYMBOL","Symbol","for","oldCatchError","options","__e","error","newVNode","oldVNode","errorInfo","then","component","vnode","__c","__k","oldUnmount","unmount","detachedClone","detachedParent","parentDom","forEach","effect","__H","assign","__P","map","child","removeOriginal","originalParent","__v","insertBefore","__d","Suspense","this","__u","_suspenders","suspended","__","__a","SuspenseList","this","_next","_map","options","unmount","vnode","component","__c","__R","__h","type","oldUnmount","Suspense","prototype","Component","promise","suspendingVNode","suspendingComponent","c","_suspenders","push","resolve","suspended","__v","resolved","onResolved","onSuspensionComplete","__u","state","__a","suspendedVNode","__k","removeOriginal","setState","__b","pop","forceUpdate","wasHydrating","then","componentWillUnmount","render","props","detachedParent","document","createElement","detachedComponent","detachedClone","__O","__P","fallback","Fragment","children","list","child","node","delete","revealOrder","size","length","SuspenseList","prototype","Component","__a","child","list","this","delegated","suspended","__v","node","_map","get","unsuspend","wrappedUnsuspend","props","revealOrder","push","resolve","render","_next","Map","children","toChildArray","reverse","i","length","set","componentDidUpdate","componentDidMount","_this","forEach","REACT_ELEMENT_TYPE","Symbol","for","CAMEL_PROPS","ON_ANI","CAMEL_REPLACE","IS_DOM","document","onChangeInputType","type","test","Component","prototype","isReactComponent","forEach","key","Object","defineProperty","configurable","get","this","set","v","writable","value","oldEventHook","options","event","empty","isPropagationStopped","cancelBubble","isDefaultPrevented","defaultPrevented","e","persist","nativeEvent","currentComponent","classNameDescriptorNonEnumberable","enumerable","class","oldVNodeHook","vnode","type","props","normalizedProps","i","IS_DOM","lowerCased","toLowerCase","onChangeInputType","ON_ANI","test","indexOf","CAMEL_PROPS","replace","CAMEL_REPLACE","multiple","Array","isArray","toChildArray","children","child","selected","defaultValue","className","$$typeof","REACT_ELEMENT_TYPE","oldBeforeRender","__r","__c","oldDiffed","diffed","dom","__e","e","t","l","a","n","o","c","e","t","s","i","p","u","d","r","f","g","b","h","m","j","isFunction","valOrFunction","resolveValue","arg","genId","count","prefersReducedMotion","shouldReduceMotion","mediaQuery","TOAST_LIMIT","toastTimeouts","TOAST_EXPIRE_DISMISS_DELAY","addToRemoveQueue","toastId","timeout","dispatch","clearFromRemoveQueue","reducer","state","action","t","toast","diff","listeners","memoryState","listener","defaultTimeouts","useStore","toastOptions","setState","useState","useEffect","index","mergedToasts","_a","_b","createToast","message","type","opts","createHandler","options","promise","msgs","id","p","e","updateHeight","height","startPause","useToaster","toasts","pausedAt","now","timeouts","durationLeft","endPause","useCallback","calculateOffset","reverseOrder","gutter","defaultPosition","relevantToasts","toastIndex","toastsBefore","i","acc","circleAnimation","keyframes","firstLineAnimation","secondLineAnimation","ErrorIcon","styled","rotate","LoaderIcon","checkmarkAnimation","CheckmarkIcon","StatusWrapper","IndicatorWrapper","enter","AnimatedIconWrapper","ToastIcon","icon","iconTheme","y","enterAnimation","factor","exitAnimation","fadeInAnimation","fadeOutAnimation","ToastBarBase","Message","getAnimationStyle","position","visible","exit","ToastBar","x","style","children","animationStyle","_","setup","ToastWrapper","className","onHeightUpdate","ref","T","el","getPositionStyle","offset","top","verticalStyle","horizontalStyle","activeClass","css","DEFAULT_OFFSET","Toaster","containerStyle","containerClassName","handlers","toastPosition","positionStyle","root","startToaster","config","n","B","y","Ie"]}